// Code generated by Prisma (prisma@1.27.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  channel: (where?: ChannelWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  commentOptions: (where?: CommentOptionsWhereInput) => Promise<boolean>;
  commentSection: (where?: CommentSectionWhereInput) => Promise<boolean>;
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  message: (where?: MessageWhereInput) => Promise<boolean>;
  moderator: (where?: ModeratorWhereInput) => Promise<boolean>;
  notification: (where?: NotificationWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  rating: (where?: RatingWhereInput) => Promise<boolean>;
  team: (where?: TeamWhereInput) => Promise<boolean>;
  teamSetting: (where?: TeamSettingWhereInput) => Promise<boolean>;
  todo: (where?: TodoWhereInput) => Promise<boolean>;
  todoProject: (where?: TodoProjectWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  channel: (where: ChannelWhereUniqueInput) => ChannelPromise;
  channels: (
    args?: {
      where?: ChannelWhereInput;
      orderBy?: ChannelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Channel>;
  channelsConnection: (
    args?: {
      where?: ChannelWhereInput;
      orderBy?: ChannelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ChannelConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentPromise;
  comments: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Comment>;
  commentsConnection: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CommentConnectionPromise;
  commentOptionses: (
    args?: {
      where?: CommentOptionsWhereInput;
      orderBy?: CommentOptionsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CommentOptions>;
  commentOptionsesConnection: (
    args?: {
      where?: CommentOptionsWhereInput;
      orderBy?: CommentOptionsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CommentOptionsConnectionPromise;
  commentSection: (
    where: CommentSectionWhereUniqueInput
  ) => CommentSectionPromise;
  commentSections: (
    args?: {
      where?: CommentSectionWhereInput;
      orderBy?: CommentSectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CommentSection>;
  commentSectionsConnection: (
    args?: {
      where?: CommentSectionWhereInput;
      orderBy?: CommentSectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CommentSectionConnectionPromise;
  customer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  customers: (
    args?: {
      where?: CustomerWhereInput;
      orderBy?: CustomerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Customer>;
  customersConnection: (
    args?: {
      where?: CustomerWhereInput;
      orderBy?: CustomerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CustomerConnectionPromise;
  file: (where: FileWhereUniqueInput) => FilePromise;
  files: (
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<File>;
  filesConnection: (
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FileConnectionPromise;
  message: (where: MessageWhereUniqueInput) => MessagePromise;
  messages: (
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Message>;
  messagesConnection: (
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MessageConnectionPromise;
  moderator: (where: ModeratorWhereUniqueInput) => ModeratorPromise;
  moderators: (
    args?: {
      where?: ModeratorWhereInput;
      orderBy?: ModeratorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Moderator>;
  moderatorsConnection: (
    args?: {
      where?: ModeratorWhereInput;
      orderBy?: ModeratorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ModeratorConnectionPromise;
  notification: (where: NotificationWhereUniqueInput) => NotificationPromise;
  notifications: (
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Notification>;
  notificationsConnection: (
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => NotificationConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderPromise;
  orders: (
    args?: {
      where?: OrderWhereInput;
      orderBy?: OrderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Order>;
  ordersConnection: (
    args?: {
      where?: OrderWhereInput;
      orderBy?: OrderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => OrderConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductPromise;
  products: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Product>;
  productsConnection: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductConnectionPromise;
  rating: (where: RatingWhereUniqueInput) => RatingPromise;
  ratings: (
    args?: {
      where?: RatingWhereInput;
      orderBy?: RatingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Rating>;
  ratingsConnection: (
    args?: {
      where?: RatingWhereInput;
      orderBy?: RatingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RatingConnectionPromise;
  team: (where: TeamWhereUniqueInput) => TeamPromise;
  teams: (
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Team>;
  teamsConnection: (
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TeamConnectionPromise;
  teamSetting: (where: TeamSettingWhereUniqueInput) => TeamSettingPromise;
  teamSettings: (
    args?: {
      where?: TeamSettingWhereInput;
      orderBy?: TeamSettingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TeamSetting>;
  teamSettingsConnection: (
    args?: {
      where?: TeamSettingWhereInput;
      orderBy?: TeamSettingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TeamSettingConnectionPromise;
  todo: (where: TodoWhereUniqueInput) => TodoPromise;
  todoes: (
    args?: {
      where?: TodoWhereInput;
      orderBy?: TodoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Todo>;
  todoesConnection: (
    args?: {
      where?: TodoWhereInput;
      orderBy?: TodoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TodoConnectionPromise;
  todoProject: (where: TodoProjectWhereUniqueInput) => TodoProjectPromise;
  todoProjects: (
    args?: {
      where?: TodoProjectWhereInput;
      orderBy?: TodoProjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TodoProject>;
  todoProjectsConnection: (
    args?: {
      where?: TodoProjectWhereInput;
      orderBy?: TodoProjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TodoProjectConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createChannel: (data: ChannelCreateInput) => ChannelPromise;
  updateChannel: (
    args: { data: ChannelUpdateInput; where: ChannelWhereUniqueInput }
  ) => ChannelPromise;
  updateManyChannels: (
    args: { data: ChannelUpdateManyMutationInput; where?: ChannelWhereInput }
  ) => BatchPayloadPromise;
  upsertChannel: (
    args: {
      where: ChannelWhereUniqueInput;
      create: ChannelCreateInput;
      update: ChannelUpdateInput;
    }
  ) => ChannelPromise;
  deleteChannel: (where: ChannelWhereUniqueInput) => ChannelPromise;
  deleteManyChannels: (where?: ChannelWhereInput) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (
    args: { data: CommentUpdateInput; where: CommentWhereUniqueInput }
  ) => CommentPromise;
  updateManyComments: (
    args: { data: CommentUpdateManyMutationInput; where?: CommentWhereInput }
  ) => BatchPayloadPromise;
  upsertComment: (
    args: {
      where: CommentWhereUniqueInput;
      create: CommentCreateInput;
      update: CommentUpdateInput;
    }
  ) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createCommentOptions: (
    data: CommentOptionsCreateInput
  ) => CommentOptionsPromise;
  updateManyCommentOptionses: (
    args: {
      data: CommentOptionsUpdateManyMutationInput;
      where?: CommentOptionsWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyCommentOptionses: (
    where?: CommentOptionsWhereInput
  ) => BatchPayloadPromise;
  createCommentSection: (
    data: CommentSectionCreateInput
  ) => CommentSectionPromise;
  updateCommentSection: (
    args: {
      data: CommentSectionUpdateInput;
      where: CommentSectionWhereUniqueInput;
    }
  ) => CommentSectionPromise;
  updateManyCommentSections: (
    args: {
      data: CommentSectionUpdateManyMutationInput;
      where?: CommentSectionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCommentSection: (
    args: {
      where: CommentSectionWhereUniqueInput;
      create: CommentSectionCreateInput;
      update: CommentSectionUpdateInput;
    }
  ) => CommentSectionPromise;
  deleteCommentSection: (
    where: CommentSectionWhereUniqueInput
  ) => CommentSectionPromise;
  deleteManyCommentSections: (
    where?: CommentSectionWhereInput
  ) => BatchPayloadPromise;
  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (
    args: { data: CustomerUpdateInput; where: CustomerWhereUniqueInput }
  ) => CustomerPromise;
  updateManyCustomers: (
    args: { data: CustomerUpdateManyMutationInput; where?: CustomerWhereInput }
  ) => BatchPayloadPromise;
  upsertCustomer: (
    args: {
      where: CustomerWhereUniqueInput;
      create: CustomerCreateInput;
      update: CustomerUpdateInput;
    }
  ) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (
    args: { data: FileUpdateInput; where: FileWhereUniqueInput }
  ) => FilePromise;
  updateManyFiles: (
    args: { data: FileUpdateManyMutationInput; where?: FileWhereInput }
  ) => BatchPayloadPromise;
  upsertFile: (
    args: {
      where: FileWhereUniqueInput;
      create: FileCreateInput;
      update: FileUpdateInput;
    }
  ) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createMessage: (data: MessageCreateInput) => MessagePromise;
  updateMessage: (
    args: { data: MessageUpdateInput; where: MessageWhereUniqueInput }
  ) => MessagePromise;
  updateManyMessages: (
    args: { data: MessageUpdateManyMutationInput; where?: MessageWhereInput }
  ) => BatchPayloadPromise;
  upsertMessage: (
    args: {
      where: MessageWhereUniqueInput;
      create: MessageCreateInput;
      update: MessageUpdateInput;
    }
  ) => MessagePromise;
  deleteMessage: (where: MessageWhereUniqueInput) => MessagePromise;
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayloadPromise;
  createModerator: (data: ModeratorCreateInput) => ModeratorPromise;
  updateModerator: (
    args: { data: ModeratorUpdateInput; where: ModeratorWhereUniqueInput }
  ) => ModeratorPromise;
  updateManyModerators: (
    args: {
      data: ModeratorUpdateManyMutationInput;
      where?: ModeratorWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertModerator: (
    args: {
      where: ModeratorWhereUniqueInput;
      create: ModeratorCreateInput;
      update: ModeratorUpdateInput;
    }
  ) => ModeratorPromise;
  deleteModerator: (where: ModeratorWhereUniqueInput) => ModeratorPromise;
  deleteManyModerators: (where?: ModeratorWhereInput) => BatchPayloadPromise;
  createNotification: (data: NotificationCreateInput) => NotificationPromise;
  updateNotification: (
    args: { data: NotificationUpdateInput; where: NotificationWhereUniqueInput }
  ) => NotificationPromise;
  updateManyNotifications: (
    args: {
      data: NotificationUpdateManyMutationInput;
      where?: NotificationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertNotification: (
    args: {
      where: NotificationWhereUniqueInput;
      create: NotificationCreateInput;
      update: NotificationUpdateInput;
    }
  ) => NotificationPromise;
  deleteNotification: (
    where: NotificationWhereUniqueInput
  ) => NotificationPromise;
  deleteManyNotifications: (
    where?: NotificationWhereInput
  ) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (
    args: { data: OrderUpdateInput; where: OrderWhereUniqueInput }
  ) => OrderPromise;
  updateManyOrders: (
    args: { data: OrderUpdateManyMutationInput; where?: OrderWhereInput }
  ) => BatchPayloadPromise;
  upsertOrder: (
    args: {
      where: OrderWhereUniqueInput;
      create: OrderCreateInput;
      update: OrderUpdateInput;
    }
  ) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (
    args: { data: ProductUpdateInput; where: ProductWhereUniqueInput }
  ) => ProductPromise;
  updateManyProducts: (
    args: { data: ProductUpdateManyMutationInput; where?: ProductWhereInput }
  ) => BatchPayloadPromise;
  upsertProduct: (
    args: {
      where: ProductWhereUniqueInput;
      create: ProductCreateInput;
      update: ProductUpdateInput;
    }
  ) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createRating: (data: RatingCreateInput) => RatingPromise;
  updateRating: (
    args: { data: RatingUpdateInput; where: RatingWhereUniqueInput }
  ) => RatingPromise;
  updateManyRatings: (
    args: { data: RatingUpdateManyMutationInput; where?: RatingWhereInput }
  ) => BatchPayloadPromise;
  upsertRating: (
    args: {
      where: RatingWhereUniqueInput;
      create: RatingCreateInput;
      update: RatingUpdateInput;
    }
  ) => RatingPromise;
  deleteRating: (where: RatingWhereUniqueInput) => RatingPromise;
  deleteManyRatings: (where?: RatingWhereInput) => BatchPayloadPromise;
  createTeam: (data: TeamCreateInput) => TeamPromise;
  updateTeam: (
    args: { data: TeamUpdateInput; where: TeamWhereUniqueInput }
  ) => TeamPromise;
  updateManyTeams: (
    args: { data: TeamUpdateManyMutationInput; where?: TeamWhereInput }
  ) => BatchPayloadPromise;
  upsertTeam: (
    args: {
      where: TeamWhereUniqueInput;
      create: TeamCreateInput;
      update: TeamUpdateInput;
    }
  ) => TeamPromise;
  deleteTeam: (where: TeamWhereUniqueInput) => TeamPromise;
  deleteManyTeams: (where?: TeamWhereInput) => BatchPayloadPromise;
  createTeamSetting: (data: TeamSettingCreateInput) => TeamSettingPromise;
  updateTeamSetting: (
    args: { data: TeamSettingUpdateInput; where: TeamSettingWhereUniqueInput }
  ) => TeamSettingPromise;
  updateManyTeamSettings: (
    args: {
      data: TeamSettingUpdateManyMutationInput;
      where?: TeamSettingWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertTeamSetting: (
    args: {
      where: TeamSettingWhereUniqueInput;
      create: TeamSettingCreateInput;
      update: TeamSettingUpdateInput;
    }
  ) => TeamSettingPromise;
  deleteTeamSetting: (where: TeamSettingWhereUniqueInput) => TeamSettingPromise;
  deleteManyTeamSettings: (
    where?: TeamSettingWhereInput
  ) => BatchPayloadPromise;
  createTodo: (data: TodoCreateInput) => TodoPromise;
  updateTodo: (
    args: { data: TodoUpdateInput; where: TodoWhereUniqueInput }
  ) => TodoPromise;
  updateManyTodoes: (
    args: { data: TodoUpdateManyMutationInput; where?: TodoWhereInput }
  ) => BatchPayloadPromise;
  upsertTodo: (
    args: {
      where: TodoWhereUniqueInput;
      create: TodoCreateInput;
      update: TodoUpdateInput;
    }
  ) => TodoPromise;
  deleteTodo: (where: TodoWhereUniqueInput) => TodoPromise;
  deleteManyTodoes: (where?: TodoWhereInput) => BatchPayloadPromise;
  createTodoProject: (data: TodoProjectCreateInput) => TodoProjectPromise;
  updateTodoProject: (
    args: { data: TodoProjectUpdateInput; where: TodoProjectWhereUniqueInput }
  ) => TodoProjectPromise;
  updateManyTodoProjects: (
    args: {
      data: TodoProjectUpdateManyMutationInput;
      where?: TodoProjectWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertTodoProject: (
    args: {
      where: TodoProjectWhereUniqueInput;
      create: TodoProjectCreateInput;
      update: TodoProjectUpdateInput;
    }
  ) => TodoProjectPromise;
  deleteTodoProject: (where: TodoProjectWhereUniqueInput) => TodoProjectPromise;
  deleteManyTodoProjects: (
    where?: TodoProjectWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  channel: (
    where?: ChannelSubscriptionWhereInput
  ) => ChannelSubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  commentOptions: (
    where?: CommentOptionsSubscriptionWhereInput
  ) => CommentOptionsSubscriptionPayloadSubscription;
  commentSection: (
    where?: CommentSectionSubscriptionWhereInput
  ) => CommentSectionSubscriptionPayloadSubscription;
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  message: (
    where?: MessageSubscriptionWhereInput
  ) => MessageSubscriptionPayloadSubscription;
  moderator: (
    where?: ModeratorSubscriptionWhereInput
  ) => ModeratorSubscriptionPayloadSubscription;
  notification: (
    where?: NotificationSubscriptionWhereInput
  ) => NotificationSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  rating: (
    where?: RatingSubscriptionWhereInput
  ) => RatingSubscriptionPayloadSubscription;
  team: (
    where?: TeamSubscriptionWhereInput
  ) => TeamSubscriptionPayloadSubscription;
  teamSetting: (
    where?: TeamSettingSubscriptionWhereInput
  ) => TeamSettingSubscriptionPayloadSubscription;
  todo: (
    where?: TodoSubscriptionWhereInput
  ) => TodoSubscriptionPayloadSubscription;
  todoProject: (
    where?: TodoProjectSubscriptionWhereInput
  ) => TodoProjectSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UserRole = "ADMIN" | "MODERATOR" | "USER";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "set_private_ASC"
  | "set_private_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "gitHubId_ASC"
  | "gitHubId_DESC"
  | "facebookId_ASC"
  | "facebookId_DESC"
  | "twitterId_ASC"
  | "twitterId_DESC"
  | "gmailId_ASC"
  | "gmailId_DESC"
  | "private_ASC"
  | "private_DESC"
  | "confirmed_ASC"
  | "confirmed_DESC"
  | "online_ASC"
  | "online_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "role_ASC"
  | "role_DESC";

export type NotificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "message_ASC"
  | "message_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "body_ASC"
  | "body_DESC"
  | "parentId_ASC"
  | "parentId_DESC"
  | "pageId_ASC"
  | "pageId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ChannelOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "public_ASC"
  | "public_DESC"
  | "teamId_ASC"
  | "teamId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TeamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "confirmed_ASC"
  | "confirmed_DESC"
  | "online_ASC"
  | "online_DESC";

export type MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "body_ASC"
  | "body_DESC"
  | "parentId_ASC"
  | "parentId_DESC"
  | "url_ASC"
  | "url_DESC"
  | "filetype_ASC"
  | "filetype_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CommentOptionsOrderByInput =
  | "comments_open_ASC"
  | "comments_open_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ModeratorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "can_delete_ASC"
  | "can_delete_DESC"
  | "can_ban_ASC"
  | "can_ban_DESC"
  | "can_edit_ASC"
  | "can_edit_DESC"
  | "can_close_ASC"
  | "can_close_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CommentSectionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "pageId_ASC"
  | "pageId_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CustomerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "stripeId_ASC"
  | "stripeId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "filename_ASC"
  | "filename_DESC"
  | "mimetype_ASC"
  | "mimetype_DESC"
  | "encoding_ASC"
  | "encoding_DESC"
  | "key_ASC"
  | "key_DESC"
  | "ETag_ASC"
  | "ETag_DESC"
  | "url_ASC"
  | "url_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "stock_ASC"
  | "stock_DESC"
  | "price_ASC"
  | "price_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "total_price_ASC"
  | "total_price_DESC"
  | "confirmed_ASC"
  | "confirmed_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RatingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "vote_ASC"
  | "vote_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TeamSettingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "cankick_ASC"
  | "cankick_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TodoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "body_ASC"
  | "body_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TodoProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ChannelWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  slug?: String;
}>;

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  notifications_every?: NotificationWhereInput;
  notifications_some?: NotificationWhereInput;
  notifications_none?: NotificationWhereInput;
  set_private?: Boolean;
  set_private_not?: Boolean;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  gitHubId?: ID_Input;
  gitHubId_not?: ID_Input;
  gitHubId_in?: ID_Input[] | ID_Input;
  gitHubId_not_in?: ID_Input[] | ID_Input;
  gitHubId_lt?: ID_Input;
  gitHubId_lte?: ID_Input;
  gitHubId_gt?: ID_Input;
  gitHubId_gte?: ID_Input;
  gitHubId_contains?: ID_Input;
  gitHubId_not_contains?: ID_Input;
  gitHubId_starts_with?: ID_Input;
  gitHubId_not_starts_with?: ID_Input;
  gitHubId_ends_with?: ID_Input;
  gitHubId_not_ends_with?: ID_Input;
  facebookId?: ID_Input;
  facebookId_not?: ID_Input;
  facebookId_in?: ID_Input[] | ID_Input;
  facebookId_not_in?: ID_Input[] | ID_Input;
  facebookId_lt?: ID_Input;
  facebookId_lte?: ID_Input;
  facebookId_gt?: ID_Input;
  facebookId_gte?: ID_Input;
  facebookId_contains?: ID_Input;
  facebookId_not_contains?: ID_Input;
  facebookId_starts_with?: ID_Input;
  facebookId_not_starts_with?: ID_Input;
  facebookId_ends_with?: ID_Input;
  facebookId_not_ends_with?: ID_Input;
  twitterId?: ID_Input;
  twitterId_not?: ID_Input;
  twitterId_in?: ID_Input[] | ID_Input;
  twitterId_not_in?: ID_Input[] | ID_Input;
  twitterId_lt?: ID_Input;
  twitterId_lte?: ID_Input;
  twitterId_gt?: ID_Input;
  twitterId_gte?: ID_Input;
  twitterId_contains?: ID_Input;
  twitterId_not_contains?: ID_Input;
  twitterId_starts_with?: ID_Input;
  twitterId_not_starts_with?: ID_Input;
  twitterId_ends_with?: ID_Input;
  twitterId_not_ends_with?: ID_Input;
  gmailId?: String;
  gmailId_not?: String;
  gmailId_in?: String[] | String;
  gmailId_not_in?: String[] | String;
  gmailId_lt?: String;
  gmailId_lte?: String;
  gmailId_gt?: String;
  gmailId_gte?: String;
  gmailId_contains?: String;
  gmailId_not_contains?: String;
  gmailId_starts_with?: String;
  gmailId_not_starts_with?: String;
  gmailId_ends_with?: String;
  gmailId_not_ends_with?: String;
  directMessages_every?: CommentWhereInput;
  directMessages_some?: CommentWhereInput;
  directMessages_none?: CommentWhereInput;
  avatar_url?: FileWhereInput;
  private?: Boolean;
  private_not?: Boolean;
  blockedUsers_every?: UserWhereInput;
  blockedUsers_some?: UserWhereInput;
  blockedUsers_none?: UserWhereInput;
  confirmed?: Boolean;
  confirmed_not?: Boolean;
  online?: Boolean;
  online_not?: Boolean;
  friends_every?: UserWhereInput;
  friends_some?: UserWhereInput;
  friends_none?: UserWhereInput;
  friend_requests_every?: UserWhereInput;
  friend_requests_some?: UserWhereInput;
  friend_requests_none?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  role?: UserRole;
  role_not?: UserRole;
  role_in?: UserRole[] | UserRole;
  role_not_in?: UserRole[] | UserRole;
  teams_every?: TeamWhereInput;
  teams_some?: TeamWhereInput;
  teams_none?: TeamWhereInput;
  channels_every?: ChannelWhereInput;
  channels_some?: ChannelWhereInput;
  channels_none?: ChannelWhereInput;
  owned_teams_every?: TeamWhereInput;
  owned_teams_some?: TeamWhereInput;
  owned_teams_none?: TeamWhereInput;
  owned_channels_every?: ChannelWhereInput;
  owned_channels_some?: ChannelWhereInput;
  owned_channels_none?: ChannelWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface NotificationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  message?: String;
  message_not?: String;
  message_in?: String[] | String;
  message_not_in?: String[] | String;
  message_lt?: String;
  message_lte?: String;
  message_gt?: String;
  message_gte?: String;
  message_contains?: String;
  message_not_contains?: String;
  message_starts_with?: String;
  message_not_starts_with?: String;
  message_ends_with?: String;
  message_not_ends_with?: String;
  comments?: CommentWhereInput;
  messages?: MessageWhereInput;
  team?: TeamWhereInput;
  channel?: ChannelWhereInput;
  friend_requests?: UserWhereInput;
  friend?: UserWhereInput;
  author?: UserWhereInput;
  AND?: NotificationWhereInput[] | NotificationWhereInput;
  OR?: NotificationWhereInput[] | NotificationWhereInput;
  NOT?: NotificationWhereInput[] | NotificationWhereInput;
}

export interface CommentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  body?: String;
  body_not?: String;
  body_in?: String[] | String;
  body_not_in?: String[] | String;
  body_lt?: String;
  body_lte?: String;
  body_gt?: String;
  body_gte?: String;
  body_contains?: String;
  body_not_contains?: String;
  body_starts_with?: String;
  body_not_starts_with?: String;
  body_ends_with?: String;
  body_not_ends_with?: String;
  parentId?: ID_Input;
  parentId_not?: ID_Input;
  parentId_in?: ID_Input[] | ID_Input;
  parentId_not_in?: ID_Input[] | ID_Input;
  parentId_lt?: ID_Input;
  parentId_lte?: ID_Input;
  parentId_gt?: ID_Input;
  parentId_gte?: ID_Input;
  parentId_contains?: ID_Input;
  parentId_not_contains?: ID_Input;
  parentId_starts_with?: ID_Input;
  parentId_not_starts_with?: ID_Input;
  parentId_ends_with?: ID_Input;
  parentId_not_ends_with?: ID_Input;
  pageId?: ID_Input;
  pageId_not?: ID_Input;
  pageId_in?: ID_Input[] | ID_Input;
  pageId_not_in?: ID_Input[] | ID_Input;
  pageId_lt?: ID_Input;
  pageId_lte?: ID_Input;
  pageId_gt?: ID_Input;
  pageId_gte?: ID_Input;
  pageId_contains?: ID_Input;
  pageId_not_contains?: ID_Input;
  pageId_starts_with?: ID_Input;
  pageId_not_starts_with?: ID_Input;
  pageId_ends_with?: ID_Input;
  pageId_not_ends_with?: ID_Input;
  repliedTo?: UserWhereInput;
  ratings?: RatingWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  replies_every?: CommentWhereInput;
  replies_some?: CommentWhereInput;
  replies_none?: CommentWhereInput;
  author?: UserWhereInput;
  AND?: CommentWhereInput[] | CommentWhereInput;
  OR?: CommentWhereInput[] | CommentWhereInput;
  NOT?: CommentWhereInput[] | CommentWhereInput;
}

export interface RatingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  vote?: Int;
  vote_not?: Int;
  vote_in?: Int[] | Int;
  vote_not_in?: Int[] | Int;
  vote_lt?: Int;
  vote_lte?: Int;
  vote_gt?: Int;
  vote_gte?: Int;
  author_every?: UserWhereInput;
  author_some?: UserWhereInput;
  author_none?: UserWhereInput;
  AND?: RatingWhereInput[] | RatingWhereInput;
  OR?: RatingWhereInput[] | RatingWhereInput;
  NOT?: RatingWhereInput[] | RatingWhereInput;
}

export interface MessageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  body?: String;
  body_not?: String;
  body_in?: String[] | String;
  body_not_in?: String[] | String;
  body_lt?: String;
  body_lte?: String;
  body_gt?: String;
  body_gte?: String;
  body_contains?: String;
  body_not_contains?: String;
  body_starts_with?: String;
  body_not_starts_with?: String;
  body_ends_with?: String;
  body_not_ends_with?: String;
  parentId?: ID_Input;
  parentId_not?: ID_Input;
  parentId_in?: ID_Input[] | ID_Input;
  parentId_not_in?: ID_Input[] | ID_Input;
  parentId_lt?: ID_Input;
  parentId_lte?: ID_Input;
  parentId_gt?: ID_Input;
  parentId_gte?: ID_Input;
  parentId_contains?: ID_Input;
  parentId_not_contains?: ID_Input;
  parentId_starts_with?: ID_Input;
  parentId_not_starts_with?: ID_Input;
  parentId_ends_with?: ID_Input;
  parentId_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  filetype?: String;
  filetype_not?: String;
  filetype_in?: String[] | String;
  filetype_not_in?: String[] | String;
  filetype_lt?: String;
  filetype_lte?: String;
  filetype_gt?: String;
  filetype_gte?: String;
  filetype_contains?: String;
  filetype_not_contains?: String;
  filetype_starts_with?: String;
  filetype_not_starts_with?: String;
  filetype_ends_with?: String;
  filetype_not_ends_with?: String;
  author?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MessageWhereInput[] | MessageWhereInput;
  OR?: MessageWhereInput[] | MessageWhereInput;
  NOT?: MessageWhereInput[] | MessageWhereInput;
}

export interface TeamWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  moderators_every?: UserWhereInput;
  moderators_some?: UserWhereInput;
  moderators_none?: UserWhereInput;
  author?: UserWhereInput;
  members_every?: UserWhereInput;
  members_some?: UserWhereInput;
  members_none?: UserWhereInput;
  channels_every?: ChannelWhereInput;
  channels_some?: ChannelWhereInput;
  channels_none?: ChannelWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  confirmed?: Boolean;
  confirmed_not?: Boolean;
  online?: Boolean;
  online_not?: Boolean;
  AND?: TeamWhereInput[] | TeamWhereInput;
  OR?: TeamWhereInput[] | TeamWhereInput;
  NOT?: TeamWhereInput[] | TeamWhereInput;
}

export interface ChannelWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  moderators_every?: UserWhereInput;
  moderators_some?: UserWhereInput;
  moderators_none?: UserWhereInput;
  public?: Boolean;
  public_not?: Boolean;
  messages_every?: MessageWhereInput;
  messages_some?: MessageWhereInput;
  messages_none?: MessageWhereInput;
  teamId?: ID_Input;
  teamId_not?: ID_Input;
  teamId_in?: ID_Input[] | ID_Input;
  teamId_not_in?: ID_Input[] | ID_Input;
  teamId_lt?: ID_Input;
  teamId_lte?: ID_Input;
  teamId_gt?: ID_Input;
  teamId_gte?: ID_Input;
  teamId_contains?: ID_Input;
  teamId_not_contains?: ID_Input;
  teamId_starts_with?: ID_Input;
  teamId_not_starts_with?: ID_Input;
  teamId_ends_with?: ID_Input;
  teamId_not_ends_with?: ID_Input;
  members_every?: UserWhereInput;
  members_some?: UserWhereInput;
  members_none?: UserWhereInput;
  author?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ChannelWhereInput[] | ChannelWhereInput;
  OR?: ChannelWhereInput[] | ChannelWhereInput;
  NOT?: ChannelWhereInput[] | ChannelWhereInput;
}

export interface FileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  filename?: String;
  filename_not?: String;
  filename_in?: String[] | String;
  filename_not_in?: String[] | String;
  filename_lt?: String;
  filename_lte?: String;
  filename_gt?: String;
  filename_gte?: String;
  filename_contains?: String;
  filename_not_contains?: String;
  filename_starts_with?: String;
  filename_not_starts_with?: String;
  filename_ends_with?: String;
  filename_not_ends_with?: String;
  mimetype?: String;
  mimetype_not?: String;
  mimetype_in?: String[] | String;
  mimetype_not_in?: String[] | String;
  mimetype_lt?: String;
  mimetype_lte?: String;
  mimetype_gt?: String;
  mimetype_gte?: String;
  mimetype_contains?: String;
  mimetype_not_contains?: String;
  mimetype_starts_with?: String;
  mimetype_not_starts_with?: String;
  mimetype_ends_with?: String;
  mimetype_not_ends_with?: String;
  encoding?: String;
  encoding_not?: String;
  encoding_in?: String[] | String;
  encoding_not_in?: String[] | String;
  encoding_lt?: String;
  encoding_lte?: String;
  encoding_gt?: String;
  encoding_gte?: String;
  encoding_contains?: String;
  encoding_not_contains?: String;
  encoding_starts_with?: String;
  encoding_not_starts_with?: String;
  encoding_ends_with?: String;
  encoding_not_ends_with?: String;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  ETag?: String;
  ETag_not?: String;
  ETag_in?: String[] | String;
  ETag_not_in?: String[] | String;
  ETag_lt?: String;
  ETag_lte?: String;
  ETag_gt?: String;
  ETag_gte?: String;
  ETag_contains?: String;
  ETag_not_contains?: String;
  ETag_starts_with?: String;
  ETag_not_starts_with?: String;
  ETag_ends_with?: String;
  ETag_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: FileWhereInput[] | FileWhereInput;
  OR?: FileWhereInput[] | FileWhereInput;
  NOT?: FileWhereInput[] | FileWhereInput;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CommentOptionsWhereInput {
  comments_open?: Boolean;
  comments_open_not?: Boolean;
  AND?: CommentOptionsWhereInput[] | CommentOptionsWhereInput;
  OR?: CommentOptionsWhereInput[] | CommentOptionsWhereInput;
  NOT?: CommentOptionsWhereInput[] | CommentOptionsWhereInput;
}

export type CommentSectionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  pageId?: ID_Input;
  url?: String;
}>;

export interface ModeratorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  can_delete?: Boolean;
  can_delete_not?: Boolean;
  can_ban?: Boolean;
  can_ban_not?: Boolean;
  can_edit?: Boolean;
  can_edit_not?: Boolean;
  can_close?: Boolean;
  can_close_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ModeratorWhereInput[] | ModeratorWhereInput;
  OR?: ModeratorWhereInput[] | ModeratorWhereInput;
  NOT?: ModeratorWhereInput[] | ModeratorWhereInput;
}

export interface CommentSectionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  pageId?: ID_Input;
  pageId_not?: ID_Input;
  pageId_in?: ID_Input[] | ID_Input;
  pageId_not_in?: ID_Input[] | ID_Input;
  pageId_lt?: ID_Input;
  pageId_lte?: ID_Input;
  pageId_gt?: ID_Input;
  pageId_gte?: ID_Input;
  pageId_contains?: ID_Input;
  pageId_not_contains?: ID_Input;
  pageId_starts_with?: ID_Input;
  pageId_not_starts_with?: ID_Input;
  pageId_ends_with?: ID_Input;
  pageId_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  admin?: UserWhereInput;
  moderators_every?: ModeratorWhereInput;
  moderators_some?: ModeratorWhereInput;
  moderators_none?: ModeratorWhereInput;
  options?: CommentOptionsWhereInput;
  bannedUsers_every?: UserWhereInput;
  bannedUsers_some?: UserWhereInput;
  bannedUsers_none?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CommentSectionWhereInput[] | CommentSectionWhereInput;
  OR?: CommentSectionWhereInput[] | CommentSectionWhereInput;
  NOT?: CommentSectionWhereInput[] | CommentSectionWhereInput;
}

export type CustomerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CustomerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  stripeId?: ID_Input;
  stripeId_not?: ID_Input;
  stripeId_in?: ID_Input[] | ID_Input;
  stripeId_not_in?: ID_Input[] | ID_Input;
  stripeId_lt?: ID_Input;
  stripeId_lte?: ID_Input;
  stripeId_gt?: ID_Input;
  stripeId_gte?: ID_Input;
  stripeId_contains?: ID_Input;
  stripeId_not_contains?: ID_Input;
  stripeId_starts_with?: ID_Input;
  stripeId_not_starts_with?: ID_Input;
  stripeId_ends_with?: ID_Input;
  stripeId_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CustomerWhereInput[] | CustomerWhereInput;
  OR?: CustomerWhereInput[] | CustomerWhereInput;
  NOT?: CustomerWhereInput[] | CustomerWhereInput;
}

export type FileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type MessageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ModeratorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type NotificationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type OrderWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  stock?: Int;
  stock_not?: Int;
  stock_in?: Int[] | Int;
  stock_not_in?: Int[] | Int;
  stock_lt?: Int;
  stock_lte?: Int;
  stock_gt?: Int;
  stock_gte?: Int;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ProductWhereInput[] | ProductWhereInput;
  OR?: ProductWhereInput[] | ProductWhereInput;
  NOT?: ProductWhereInput[] | ProductWhereInput;
}

export interface OrderWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  customer?: CustomerWhereInput;
  total_price?: Float;
  total_price_not?: Float;
  total_price_in?: Float[] | Float;
  total_price_not_in?: Float[] | Float;
  total_price_lt?: Float;
  total_price_lte?: Float;
  total_price_gt?: Float;
  total_price_gte?: Float;
  confirmed?: Boolean;
  confirmed_not?: Boolean;
  currency?: String;
  currency_not?: String;
  currency_in?: String[] | String;
  currency_not_in?: String[] | String;
  currency_lt?: String;
  currency_lte?: String;
  currency_gt?: String;
  currency_gte?: String;
  currency_contains?: String;
  currency_not_contains?: String;
  currency_starts_with?: String;
  currency_not_starts_with?: String;
  currency_ends_with?: String;
  currency_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: OrderWhereInput[] | OrderWhereInput;
  OR?: OrderWhereInput[] | OrderWhereInput;
  NOT?: OrderWhereInput[] | OrderWhereInput;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export type RatingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TeamWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  slug?: String;
}>;

export type TeamSettingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TeamSettingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  cankick?: Boolean;
  cankick_not?: Boolean;
  AND?: TeamSettingWhereInput[] | TeamSettingWhereInput;
  OR?: TeamSettingWhereInput[] | TeamSettingWhereInput;
  NOT?: TeamSettingWhereInput[] | TeamSettingWhereInput;
}

export type TodoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TodoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  body?: String;
  body_not?: String;
  body_in?: String[] | String;
  body_not_in?: String[] | String;
  body_lt?: String;
  body_lte?: String;
  body_gt?: String;
  body_gte?: String;
  body_contains?: String;
  body_not_contains?: String;
  body_starts_with?: String;
  body_not_starts_with?: String;
  body_ends_with?: String;
  body_not_ends_with?: String;
  author?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: TodoWhereInput[] | TodoWhereInput;
  OR?: TodoWhereInput[] | TodoWhereInput;
  NOT?: TodoWhereInput[] | TodoWhereInput;
}

export type TodoProjectWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TodoProjectWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  todos_every?: TodoWhereInput;
  todos_some?: TodoWhereInput;
  todos_none?: TodoWhereInput;
  author?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: TodoProjectWhereInput[] | TodoProjectWhereInput;
  OR?: TodoProjectWhereInput[] | TodoProjectWhereInput;
  NOT?: TodoProjectWhereInput[] | TodoProjectWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
  username?: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
}>;

export interface ChannelCreateInput {
  name: String;
  slug: String;
  moderators?: UserCreateManyInput;
  public?: Boolean;
  messages?: MessageCreateManyInput;
  teamId: ID_Input;
  members?: UserCreateManyWithoutChannelsInput;
  author: UserCreateOneWithoutOwned_channelsInput;
}

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateInput {
  email?: String;
  notifications?: NotificationCreateManyInput;
  set_private?: Boolean;
  username: String;
  password: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentCreateManyInput;
  avatar_url: FileCreateOneInput;
  private?: Boolean;
  blockedUsers?: UserCreateManyWithoutBlockedUsersInput;
  confirmed?: Boolean;
  online?: Boolean;
  friends?: UserCreateManyWithoutFriendsInput;
  friend_requests?: UserCreateManyWithoutFriend_requestsInput;
  role: UserRole;
  teams?: TeamCreateManyWithoutMembersInput;
  channels?: ChannelCreateManyWithoutMembersInput;
  owned_teams?: TeamCreateManyWithoutAuthorInput;
  owned_channels?: ChannelCreateManyWithoutAuthorInput;
}

export interface NotificationCreateManyInput {
  create?: NotificationCreateInput[] | NotificationCreateInput;
  connect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
}

export interface NotificationCreateInput {
  message?: String;
  comments?: CommentCreateOneInput;
  messages?: MessageCreateOneInput;
  team?: TeamCreateOneInput;
  channel?: ChannelCreateOneInput;
  friend_requests?: UserCreateOneInput;
  friend?: UserCreateOneInput;
  author: UserCreateOneInput;
}

export interface CommentCreateOneInput {
  create?: CommentCreateInput;
  connect?: CommentWhereUniqueInput;
}

export interface CommentCreateInput {
  body: String;
  parentId: ID_Input;
  pageId: ID_Input;
  repliedTo?: UserCreateOneInput;
  ratings: RatingCreateOneInput;
  replies?: CommentCreateManyWithoutRepliesInput;
  author: UserCreateOneInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface RatingCreateOneInput {
  create?: RatingCreateInput;
  connect?: RatingWhereUniqueInput;
}

export interface RatingCreateInput {
  vote: Int;
  author?: UserCreateManyInput;
}

export interface CommentCreateManyWithoutRepliesInput {
  create?:
    | CommentCreateWithoutRepliesInput[]
    | CommentCreateWithoutRepliesInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface CommentCreateWithoutRepliesInput {
  body: String;
  parentId: ID_Input;
  pageId: ID_Input;
  repliedTo?: UserCreateOneInput;
  ratings: RatingCreateOneInput;
  author: UserCreateOneInput;
}

export interface MessageCreateOneInput {
  create?: MessageCreateInput;
  connect?: MessageWhereUniqueInput;
}

export interface MessageCreateInput {
  body: String;
  parentId: ID_Input;
  url: String;
  filetype: String;
  author: UserCreateOneInput;
}

export interface TeamCreateOneInput {
  create?: TeamCreateInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamCreateInput {
  name: String;
  slug: String;
  moderators?: UserCreateManyInput;
  author: UserCreateOneWithoutOwned_teamsInput;
  members?: UserCreateManyWithoutTeamsInput;
  channels?: ChannelCreateManyInput;
  confirmed?: Boolean;
  online?: Boolean;
}

export interface UserCreateOneWithoutOwned_teamsInput {
  create?: UserCreateWithoutOwned_teamsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutOwned_teamsInput {
  email?: String;
  notifications?: NotificationCreateManyInput;
  set_private?: Boolean;
  username: String;
  password: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentCreateManyInput;
  avatar_url: FileCreateOneInput;
  private?: Boolean;
  blockedUsers?: UserCreateManyWithoutBlockedUsersInput;
  confirmed?: Boolean;
  online?: Boolean;
  friends?: UserCreateManyWithoutFriendsInput;
  friend_requests?: UserCreateManyWithoutFriend_requestsInput;
  role: UserRole;
  teams?: TeamCreateManyWithoutMembersInput;
  channels?: ChannelCreateManyWithoutMembersInput;
  owned_channels?: ChannelCreateManyWithoutAuthorInput;
}

export interface CommentCreateManyInput {
  create?: CommentCreateInput[] | CommentCreateInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface FileCreateOneInput {
  create?: FileCreateInput;
  connect?: FileWhereUniqueInput;
}

export interface FileCreateInput {
  filename: String;
  mimetype: String;
  encoding: String;
  key: String;
  ETag: String;
  url: String;
}

export interface UserCreateManyWithoutBlockedUsersInput {
  create?:
    | UserCreateWithoutBlockedUsersInput[]
    | UserCreateWithoutBlockedUsersInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutBlockedUsersInput {
  email?: String;
  notifications?: NotificationCreateManyInput;
  set_private?: Boolean;
  username: String;
  password: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentCreateManyInput;
  avatar_url: FileCreateOneInput;
  private?: Boolean;
  confirmed?: Boolean;
  online?: Boolean;
  friends?: UserCreateManyWithoutFriendsInput;
  friend_requests?: UserCreateManyWithoutFriend_requestsInput;
  role: UserRole;
  teams?: TeamCreateManyWithoutMembersInput;
  channels?: ChannelCreateManyWithoutMembersInput;
  owned_teams?: TeamCreateManyWithoutAuthorInput;
  owned_channels?: ChannelCreateManyWithoutAuthorInput;
}

export interface UserCreateManyWithoutFriendsInput {
  create?: UserCreateWithoutFriendsInput[] | UserCreateWithoutFriendsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutFriendsInput {
  email?: String;
  notifications?: NotificationCreateManyInput;
  set_private?: Boolean;
  username: String;
  password: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentCreateManyInput;
  avatar_url: FileCreateOneInput;
  private?: Boolean;
  blockedUsers?: UserCreateManyWithoutBlockedUsersInput;
  confirmed?: Boolean;
  online?: Boolean;
  friend_requests?: UserCreateManyWithoutFriend_requestsInput;
  role: UserRole;
  teams?: TeamCreateManyWithoutMembersInput;
  channels?: ChannelCreateManyWithoutMembersInput;
  owned_teams?: TeamCreateManyWithoutAuthorInput;
  owned_channels?: ChannelCreateManyWithoutAuthorInput;
}

export interface UserCreateManyWithoutFriend_requestsInput {
  create?:
    | UserCreateWithoutFriend_requestsInput[]
    | UserCreateWithoutFriend_requestsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutFriend_requestsInput {
  email?: String;
  notifications?: NotificationCreateManyInput;
  set_private?: Boolean;
  username: String;
  password: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentCreateManyInput;
  avatar_url: FileCreateOneInput;
  private?: Boolean;
  blockedUsers?: UserCreateManyWithoutBlockedUsersInput;
  confirmed?: Boolean;
  online?: Boolean;
  friends?: UserCreateManyWithoutFriendsInput;
  role: UserRole;
  teams?: TeamCreateManyWithoutMembersInput;
  channels?: ChannelCreateManyWithoutMembersInput;
  owned_teams?: TeamCreateManyWithoutAuthorInput;
  owned_channels?: ChannelCreateManyWithoutAuthorInput;
}

export interface TeamCreateManyWithoutMembersInput {
  create?: TeamCreateWithoutMembersInput[] | TeamCreateWithoutMembersInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
}

export interface TeamCreateWithoutMembersInput {
  name: String;
  slug: String;
  moderators?: UserCreateManyInput;
  author: UserCreateOneWithoutOwned_teamsInput;
  channels?: ChannelCreateManyInput;
  confirmed?: Boolean;
  online?: Boolean;
}

export interface ChannelCreateManyInput {
  create?: ChannelCreateInput[] | ChannelCreateInput;
  connect?: ChannelWhereUniqueInput[] | ChannelWhereUniqueInput;
}

export interface ChannelCreateManyWithoutMembersInput {
  create?:
    | ChannelCreateWithoutMembersInput[]
    | ChannelCreateWithoutMembersInput;
  connect?: ChannelWhereUniqueInput[] | ChannelWhereUniqueInput;
}

export interface ChannelCreateWithoutMembersInput {
  name: String;
  slug: String;
  moderators?: UserCreateManyInput;
  public?: Boolean;
  messages?: MessageCreateManyInput;
  teamId: ID_Input;
  author: UserCreateOneWithoutOwned_channelsInput;
}

export interface MessageCreateManyInput {
  create?: MessageCreateInput[] | MessageCreateInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
}

export interface UserCreateOneWithoutOwned_channelsInput {
  create?: UserCreateWithoutOwned_channelsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutOwned_channelsInput {
  email?: String;
  notifications?: NotificationCreateManyInput;
  set_private?: Boolean;
  username: String;
  password: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentCreateManyInput;
  avatar_url: FileCreateOneInput;
  private?: Boolean;
  blockedUsers?: UserCreateManyWithoutBlockedUsersInput;
  confirmed?: Boolean;
  online?: Boolean;
  friends?: UserCreateManyWithoutFriendsInput;
  friend_requests?: UserCreateManyWithoutFriend_requestsInput;
  role: UserRole;
  teams?: TeamCreateManyWithoutMembersInput;
  channels?: ChannelCreateManyWithoutMembersInput;
  owned_teams?: TeamCreateManyWithoutAuthorInput;
}

export interface TeamCreateManyWithoutAuthorInput {
  create?: TeamCreateWithoutAuthorInput[] | TeamCreateWithoutAuthorInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
}

export interface TeamCreateWithoutAuthorInput {
  name: String;
  slug: String;
  moderators?: UserCreateManyInput;
  members?: UserCreateManyWithoutTeamsInput;
  channels?: ChannelCreateManyInput;
  confirmed?: Boolean;
  online?: Boolean;
}

export interface UserCreateManyWithoutTeamsInput {
  create?: UserCreateWithoutTeamsInput[] | UserCreateWithoutTeamsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutTeamsInput {
  email?: String;
  notifications?: NotificationCreateManyInput;
  set_private?: Boolean;
  username: String;
  password: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentCreateManyInput;
  avatar_url: FileCreateOneInput;
  private?: Boolean;
  blockedUsers?: UserCreateManyWithoutBlockedUsersInput;
  confirmed?: Boolean;
  online?: Boolean;
  friends?: UserCreateManyWithoutFriendsInput;
  friend_requests?: UserCreateManyWithoutFriend_requestsInput;
  role: UserRole;
  channels?: ChannelCreateManyWithoutMembersInput;
  owned_teams?: TeamCreateManyWithoutAuthorInput;
  owned_channels?: ChannelCreateManyWithoutAuthorInput;
}

export interface ChannelCreateManyWithoutAuthorInput {
  create?: ChannelCreateWithoutAuthorInput[] | ChannelCreateWithoutAuthorInput;
  connect?: ChannelWhereUniqueInput[] | ChannelWhereUniqueInput;
}

export interface ChannelCreateWithoutAuthorInput {
  name: String;
  slug: String;
  moderators?: UserCreateManyInput;
  public?: Boolean;
  messages?: MessageCreateManyInput;
  teamId: ID_Input;
  members?: UserCreateManyWithoutChannelsInput;
}

export interface UserCreateManyWithoutChannelsInput {
  create?: UserCreateWithoutChannelsInput[] | UserCreateWithoutChannelsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutChannelsInput {
  email?: String;
  notifications?: NotificationCreateManyInput;
  set_private?: Boolean;
  username: String;
  password: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentCreateManyInput;
  avatar_url: FileCreateOneInput;
  private?: Boolean;
  blockedUsers?: UserCreateManyWithoutBlockedUsersInput;
  confirmed?: Boolean;
  online?: Boolean;
  friends?: UserCreateManyWithoutFriendsInput;
  friend_requests?: UserCreateManyWithoutFriend_requestsInput;
  role: UserRole;
  teams?: TeamCreateManyWithoutMembersInput;
  owned_teams?: TeamCreateManyWithoutAuthorInput;
  owned_channels?: ChannelCreateManyWithoutAuthorInput;
}

export interface ChannelCreateOneInput {
  create?: ChannelCreateInput;
  connect?: ChannelWhereUniqueInput;
}

export interface ChannelUpdateInput {
  name?: String;
  slug?: String;
  moderators?: UserUpdateManyInput;
  public?: Boolean;
  messages?: MessageUpdateManyInput;
  teamId?: ID_Input;
  members?: UserUpdateManyWithoutChannelsInput;
  author?: UserUpdateOneRequiredWithoutOwned_channelsInput;
}

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface UserUpdateDataInput {
  email?: String;
  notifications?: NotificationUpdateManyInput;
  set_private?: Boolean;
  username?: String;
  password?: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentUpdateManyInput;
  avatar_url?: FileUpdateOneRequiredInput;
  private?: Boolean;
  blockedUsers?: UserUpdateManyWithoutBlockedUsersInput;
  confirmed?: Boolean;
  online?: Boolean;
  friends?: UserUpdateManyWithoutFriendsInput;
  friend_requests?: UserUpdateManyWithoutFriend_requestsInput;
  role?: UserRole;
  teams?: TeamUpdateManyWithoutMembersInput;
  channels?: ChannelUpdateManyWithoutMembersInput;
  owned_teams?: TeamUpdateManyWithoutAuthorInput;
  owned_channels?: ChannelUpdateManyWithoutAuthorInput;
}

export interface NotificationUpdateManyInput {
  create?: NotificationCreateInput[] | NotificationCreateInput;
  update?:
    | NotificationUpdateWithWhereUniqueNestedInput[]
    | NotificationUpdateWithWhereUniqueNestedInput;
  upsert?:
    | NotificationUpsertWithWhereUniqueNestedInput[]
    | NotificationUpsertWithWhereUniqueNestedInput;
  delete?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  connect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  set?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  disconnect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  deleteMany?: NotificationScalarWhereInput[] | NotificationScalarWhereInput;
  updateMany?:
    | NotificationUpdateManyWithWhereNestedInput[]
    | NotificationUpdateManyWithWhereNestedInput;
}

export interface NotificationUpdateWithWhereUniqueNestedInput {
  where: NotificationWhereUniqueInput;
  data: NotificationUpdateDataInput;
}

export interface NotificationUpdateDataInput {
  message?: String;
  comments?: CommentUpdateOneInput;
  messages?: MessageUpdateOneInput;
  team?: TeamUpdateOneInput;
  channel?: ChannelUpdateOneInput;
  friend_requests?: UserUpdateOneInput;
  friend?: UserUpdateOneInput;
  author?: UserUpdateOneRequiredInput;
}

export interface CommentUpdateOneInput {
  create?: CommentCreateInput;
  update?: CommentUpdateDataInput;
  upsert?: CommentUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CommentWhereUniqueInput;
}

export interface CommentUpdateDataInput {
  body?: String;
  parentId?: ID_Input;
  pageId?: ID_Input;
  repliedTo?: UserUpdateOneInput;
  ratings?: RatingUpdateOneRequiredInput;
  replies?: CommentUpdateManyWithoutRepliesInput;
  author?: UserUpdateOneRequiredInput;
}

export interface UserUpdateOneInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface RatingUpdateOneRequiredInput {
  create?: RatingCreateInput;
  update?: RatingUpdateDataInput;
  upsert?: RatingUpsertNestedInput;
  connect?: RatingWhereUniqueInput;
}

export interface RatingUpdateDataInput {
  vote?: Int;
  author?: UserUpdateManyInput;
}

export interface RatingUpsertNestedInput {
  update: RatingUpdateDataInput;
  create: RatingCreateInput;
}

export interface CommentUpdateManyWithoutRepliesInput {
  create?:
    | CommentCreateWithoutRepliesInput[]
    | CommentCreateWithoutRepliesInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  set?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutRepliesInput[]
    | CommentUpdateWithWhereUniqueWithoutRepliesInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutRepliesInput[]
    | CommentUpsertWithWhereUniqueWithoutRepliesInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface CommentUpdateWithWhereUniqueWithoutRepliesInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutRepliesDataInput;
}

export interface CommentUpdateWithoutRepliesDataInput {
  body?: String;
  parentId?: ID_Input;
  pageId?: ID_Input;
  repliedTo?: UserUpdateOneInput;
  ratings?: RatingUpdateOneRequiredInput;
  author?: UserUpdateOneRequiredInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface CommentUpsertWithWhereUniqueWithoutRepliesInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutRepliesDataInput;
  create: CommentCreateWithoutRepliesInput;
}

export interface CommentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  body?: String;
  body_not?: String;
  body_in?: String[] | String;
  body_not_in?: String[] | String;
  body_lt?: String;
  body_lte?: String;
  body_gt?: String;
  body_gte?: String;
  body_contains?: String;
  body_not_contains?: String;
  body_starts_with?: String;
  body_not_starts_with?: String;
  body_ends_with?: String;
  body_not_ends_with?: String;
  parentId?: ID_Input;
  parentId_not?: ID_Input;
  parentId_in?: ID_Input[] | ID_Input;
  parentId_not_in?: ID_Input[] | ID_Input;
  parentId_lt?: ID_Input;
  parentId_lte?: ID_Input;
  parentId_gt?: ID_Input;
  parentId_gte?: ID_Input;
  parentId_contains?: ID_Input;
  parentId_not_contains?: ID_Input;
  parentId_starts_with?: ID_Input;
  parentId_not_starts_with?: ID_Input;
  parentId_ends_with?: ID_Input;
  parentId_not_ends_with?: ID_Input;
  pageId?: ID_Input;
  pageId_not?: ID_Input;
  pageId_in?: ID_Input[] | ID_Input;
  pageId_not_in?: ID_Input[] | ID_Input;
  pageId_lt?: ID_Input;
  pageId_lte?: ID_Input;
  pageId_gt?: ID_Input;
  pageId_gte?: ID_Input;
  pageId_contains?: ID_Input;
  pageId_not_contains?: ID_Input;
  pageId_starts_with?: ID_Input;
  pageId_not_starts_with?: ID_Input;
  pageId_ends_with?: ID_Input;
  pageId_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  OR?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  NOT?: CommentScalarWhereInput[] | CommentScalarWhereInput;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface CommentUpdateManyDataInput {
  body?: String;
  parentId?: ID_Input;
  pageId?: ID_Input;
}

export interface CommentUpsertNestedInput {
  update: CommentUpdateDataInput;
  create: CommentCreateInput;
}

export interface MessageUpdateOneInput {
  create?: MessageCreateInput;
  update?: MessageUpdateDataInput;
  upsert?: MessageUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MessageWhereUniqueInput;
}

export interface MessageUpdateDataInput {
  body?: String;
  parentId?: ID_Input;
  url?: String;
  filetype?: String;
  author?: UserUpdateOneRequiredInput;
}

export interface MessageUpsertNestedInput {
  update: MessageUpdateDataInput;
  create: MessageCreateInput;
}

export interface TeamUpdateOneInput {
  create?: TeamCreateInput;
  update?: TeamUpdateDataInput;
  upsert?: TeamUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TeamWhereUniqueInput;
}

export interface TeamUpdateDataInput {
  name?: String;
  slug?: String;
  moderators?: UserUpdateManyInput;
  author?: UserUpdateOneRequiredWithoutOwned_teamsInput;
  members?: UserUpdateManyWithoutTeamsInput;
  channels?: ChannelUpdateManyInput;
  confirmed?: Boolean;
  online?: Boolean;
}

export interface UserUpdateOneRequiredWithoutOwned_teamsInput {
  create?: UserCreateWithoutOwned_teamsInput;
  update?: UserUpdateWithoutOwned_teamsDataInput;
  upsert?: UserUpsertWithoutOwned_teamsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutOwned_teamsDataInput {
  email?: String;
  notifications?: NotificationUpdateManyInput;
  set_private?: Boolean;
  username?: String;
  password?: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentUpdateManyInput;
  avatar_url?: FileUpdateOneRequiredInput;
  private?: Boolean;
  blockedUsers?: UserUpdateManyWithoutBlockedUsersInput;
  confirmed?: Boolean;
  online?: Boolean;
  friends?: UserUpdateManyWithoutFriendsInput;
  friend_requests?: UserUpdateManyWithoutFriend_requestsInput;
  role?: UserRole;
  teams?: TeamUpdateManyWithoutMembersInput;
  channels?: ChannelUpdateManyWithoutMembersInput;
  owned_channels?: ChannelUpdateManyWithoutAuthorInput;
}

export interface CommentUpdateManyInput {
  create?: CommentCreateInput[] | CommentCreateInput;
  update?:
    | CommentUpdateWithWhereUniqueNestedInput[]
    | CommentUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CommentUpsertWithWhereUniqueNestedInput[]
    | CommentUpsertWithWhereUniqueNestedInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  set?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface CommentUpdateWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateDataInput;
}

export interface CommentUpsertWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateDataInput;
  create: CommentCreateInput;
}

export interface FileUpdateOneRequiredInput {
  create?: FileCreateInput;
  update?: FileUpdateDataInput;
  upsert?: FileUpsertNestedInput;
  connect?: FileWhereUniqueInput;
}

export interface FileUpdateDataInput {
  filename?: String;
  mimetype?: String;
  encoding?: String;
  key?: String;
  ETag?: String;
  url?: String;
}

export interface FileUpsertNestedInput {
  update: FileUpdateDataInput;
  create: FileCreateInput;
}

export interface UserUpdateManyWithoutBlockedUsersInput {
  create?:
    | UserCreateWithoutBlockedUsersInput[]
    | UserCreateWithoutBlockedUsersInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutBlockedUsersInput[]
    | UserUpdateWithWhereUniqueWithoutBlockedUsersInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutBlockedUsersInput[]
    | UserUpsertWithWhereUniqueWithoutBlockedUsersInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutBlockedUsersInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutBlockedUsersDataInput;
}

export interface UserUpdateWithoutBlockedUsersDataInput {
  email?: String;
  notifications?: NotificationUpdateManyInput;
  set_private?: Boolean;
  username?: String;
  password?: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentUpdateManyInput;
  avatar_url?: FileUpdateOneRequiredInput;
  private?: Boolean;
  confirmed?: Boolean;
  online?: Boolean;
  friends?: UserUpdateManyWithoutFriendsInput;
  friend_requests?: UserUpdateManyWithoutFriend_requestsInput;
  role?: UserRole;
  teams?: TeamUpdateManyWithoutMembersInput;
  channels?: ChannelUpdateManyWithoutMembersInput;
  owned_teams?: TeamUpdateManyWithoutAuthorInput;
  owned_channels?: ChannelUpdateManyWithoutAuthorInput;
}

export interface UserUpdateManyWithoutFriendsInput {
  create?: UserCreateWithoutFriendsInput[] | UserCreateWithoutFriendsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutFriendsInput[]
    | UserUpdateWithWhereUniqueWithoutFriendsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutFriendsInput[]
    | UserUpsertWithWhereUniqueWithoutFriendsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutFriendsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutFriendsDataInput;
}

export interface UserUpdateWithoutFriendsDataInput {
  email?: String;
  notifications?: NotificationUpdateManyInput;
  set_private?: Boolean;
  username?: String;
  password?: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentUpdateManyInput;
  avatar_url?: FileUpdateOneRequiredInput;
  private?: Boolean;
  blockedUsers?: UserUpdateManyWithoutBlockedUsersInput;
  confirmed?: Boolean;
  online?: Boolean;
  friend_requests?: UserUpdateManyWithoutFriend_requestsInput;
  role?: UserRole;
  teams?: TeamUpdateManyWithoutMembersInput;
  channels?: ChannelUpdateManyWithoutMembersInput;
  owned_teams?: TeamUpdateManyWithoutAuthorInput;
  owned_channels?: ChannelUpdateManyWithoutAuthorInput;
}

export interface UserUpdateManyWithoutFriend_requestsInput {
  create?:
    | UserCreateWithoutFriend_requestsInput[]
    | UserCreateWithoutFriend_requestsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutFriend_requestsInput[]
    | UserUpdateWithWhereUniqueWithoutFriend_requestsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutFriend_requestsInput[]
    | UserUpsertWithWhereUniqueWithoutFriend_requestsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutFriend_requestsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutFriend_requestsDataInput;
}

export interface UserUpdateWithoutFriend_requestsDataInput {
  email?: String;
  notifications?: NotificationUpdateManyInput;
  set_private?: Boolean;
  username?: String;
  password?: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentUpdateManyInput;
  avatar_url?: FileUpdateOneRequiredInput;
  private?: Boolean;
  blockedUsers?: UserUpdateManyWithoutBlockedUsersInput;
  confirmed?: Boolean;
  online?: Boolean;
  friends?: UserUpdateManyWithoutFriendsInput;
  role?: UserRole;
  teams?: TeamUpdateManyWithoutMembersInput;
  channels?: ChannelUpdateManyWithoutMembersInput;
  owned_teams?: TeamUpdateManyWithoutAuthorInput;
  owned_channels?: ChannelUpdateManyWithoutAuthorInput;
}

export interface TeamUpdateManyWithoutMembersInput {
  create?: TeamCreateWithoutMembersInput[] | TeamCreateWithoutMembersInput;
  delete?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  set?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  disconnect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  update?:
    | TeamUpdateWithWhereUniqueWithoutMembersInput[]
    | TeamUpdateWithWhereUniqueWithoutMembersInput;
  upsert?:
    | TeamUpsertWithWhereUniqueWithoutMembersInput[]
    | TeamUpsertWithWhereUniqueWithoutMembersInput;
  deleteMany?: TeamScalarWhereInput[] | TeamScalarWhereInput;
  updateMany?:
    | TeamUpdateManyWithWhereNestedInput[]
    | TeamUpdateManyWithWhereNestedInput;
}

export interface TeamUpdateWithWhereUniqueWithoutMembersInput {
  where: TeamWhereUniqueInput;
  data: TeamUpdateWithoutMembersDataInput;
}

export interface TeamUpdateWithoutMembersDataInput {
  name?: String;
  slug?: String;
  moderators?: UserUpdateManyInput;
  author?: UserUpdateOneRequiredWithoutOwned_teamsInput;
  channels?: ChannelUpdateManyInput;
  confirmed?: Boolean;
  online?: Boolean;
}

export interface ChannelUpdateManyInput {
  create?: ChannelCreateInput[] | ChannelCreateInput;
  update?:
    | ChannelUpdateWithWhereUniqueNestedInput[]
    | ChannelUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ChannelUpsertWithWhereUniqueNestedInput[]
    | ChannelUpsertWithWhereUniqueNestedInput;
  delete?: ChannelWhereUniqueInput[] | ChannelWhereUniqueInput;
  connect?: ChannelWhereUniqueInput[] | ChannelWhereUniqueInput;
  set?: ChannelWhereUniqueInput[] | ChannelWhereUniqueInput;
  disconnect?: ChannelWhereUniqueInput[] | ChannelWhereUniqueInput;
  deleteMany?: ChannelScalarWhereInput[] | ChannelScalarWhereInput;
  updateMany?:
    | ChannelUpdateManyWithWhereNestedInput[]
    | ChannelUpdateManyWithWhereNestedInput;
}

export interface ChannelUpdateWithWhereUniqueNestedInput {
  where: ChannelWhereUniqueInput;
  data: ChannelUpdateDataInput;
}

export interface ChannelUpdateDataInput {
  name?: String;
  slug?: String;
  moderators?: UserUpdateManyInput;
  public?: Boolean;
  messages?: MessageUpdateManyInput;
  teamId?: ID_Input;
  members?: UserUpdateManyWithoutChannelsInput;
  author?: UserUpdateOneRequiredWithoutOwned_channelsInput;
}

export interface MessageUpdateManyInput {
  create?: MessageCreateInput[] | MessageCreateInput;
  update?:
    | MessageUpdateWithWhereUniqueNestedInput[]
    | MessageUpdateWithWhereUniqueNestedInput;
  upsert?:
    | MessageUpsertWithWhereUniqueNestedInput[]
    | MessageUpsertWithWhereUniqueNestedInput;
  delete?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  set?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  disconnect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  deleteMany?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  updateMany?:
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput;
}

export interface MessageUpdateWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateDataInput;
}

export interface MessageUpsertWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateDataInput;
  create: MessageCreateInput;
}

export interface MessageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  body?: String;
  body_not?: String;
  body_in?: String[] | String;
  body_not_in?: String[] | String;
  body_lt?: String;
  body_lte?: String;
  body_gt?: String;
  body_gte?: String;
  body_contains?: String;
  body_not_contains?: String;
  body_starts_with?: String;
  body_not_starts_with?: String;
  body_ends_with?: String;
  body_not_ends_with?: String;
  parentId?: ID_Input;
  parentId_not?: ID_Input;
  parentId_in?: ID_Input[] | ID_Input;
  parentId_not_in?: ID_Input[] | ID_Input;
  parentId_lt?: ID_Input;
  parentId_lte?: ID_Input;
  parentId_gt?: ID_Input;
  parentId_gte?: ID_Input;
  parentId_contains?: ID_Input;
  parentId_not_contains?: ID_Input;
  parentId_starts_with?: ID_Input;
  parentId_not_starts_with?: ID_Input;
  parentId_ends_with?: ID_Input;
  parentId_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  filetype?: String;
  filetype_not?: String;
  filetype_in?: String[] | String;
  filetype_not_in?: String[] | String;
  filetype_lt?: String;
  filetype_lte?: String;
  filetype_gt?: String;
  filetype_gte?: String;
  filetype_contains?: String;
  filetype_not_contains?: String;
  filetype_starts_with?: String;
  filetype_not_starts_with?: String;
  filetype_ends_with?: String;
  filetype_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  OR?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  NOT?: MessageScalarWhereInput[] | MessageScalarWhereInput;
}

export interface MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput;
  data: MessageUpdateManyDataInput;
}

export interface MessageUpdateManyDataInput {
  body?: String;
  parentId?: ID_Input;
  url?: String;
  filetype?: String;
}

export interface UserUpdateManyWithoutChannelsInput {
  create?: UserCreateWithoutChannelsInput[] | UserCreateWithoutChannelsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutChannelsInput[]
    | UserUpdateWithWhereUniqueWithoutChannelsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutChannelsInput[]
    | UserUpsertWithWhereUniqueWithoutChannelsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutChannelsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutChannelsDataInput;
}

export interface UserUpdateWithoutChannelsDataInput {
  email?: String;
  notifications?: NotificationUpdateManyInput;
  set_private?: Boolean;
  username?: String;
  password?: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentUpdateManyInput;
  avatar_url?: FileUpdateOneRequiredInput;
  private?: Boolean;
  blockedUsers?: UserUpdateManyWithoutBlockedUsersInput;
  confirmed?: Boolean;
  online?: Boolean;
  friends?: UserUpdateManyWithoutFriendsInput;
  friend_requests?: UserUpdateManyWithoutFriend_requestsInput;
  role?: UserRole;
  teams?: TeamUpdateManyWithoutMembersInput;
  owned_teams?: TeamUpdateManyWithoutAuthorInput;
  owned_channels?: ChannelUpdateManyWithoutAuthorInput;
}

export interface TeamUpdateManyWithoutAuthorInput {
  create?: TeamCreateWithoutAuthorInput[] | TeamCreateWithoutAuthorInput;
  delete?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  set?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  disconnect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  update?:
    | TeamUpdateWithWhereUniqueWithoutAuthorInput[]
    | TeamUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | TeamUpsertWithWhereUniqueWithoutAuthorInput[]
    | TeamUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: TeamScalarWhereInput[] | TeamScalarWhereInput;
  updateMany?:
    | TeamUpdateManyWithWhereNestedInput[]
    | TeamUpdateManyWithWhereNestedInput;
}

export interface TeamUpdateWithWhereUniqueWithoutAuthorInput {
  where: TeamWhereUniqueInput;
  data: TeamUpdateWithoutAuthorDataInput;
}

export interface TeamUpdateWithoutAuthorDataInput {
  name?: String;
  slug?: String;
  moderators?: UserUpdateManyInput;
  members?: UserUpdateManyWithoutTeamsInput;
  channels?: ChannelUpdateManyInput;
  confirmed?: Boolean;
  online?: Boolean;
}

export interface UserUpdateManyWithoutTeamsInput {
  create?: UserCreateWithoutTeamsInput[] | UserCreateWithoutTeamsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutTeamsInput[]
    | UserUpdateWithWhereUniqueWithoutTeamsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutTeamsInput[]
    | UserUpsertWithWhereUniqueWithoutTeamsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutTeamsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutTeamsDataInput;
}

export interface UserUpdateWithoutTeamsDataInput {
  email?: String;
  notifications?: NotificationUpdateManyInput;
  set_private?: Boolean;
  username?: String;
  password?: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentUpdateManyInput;
  avatar_url?: FileUpdateOneRequiredInput;
  private?: Boolean;
  blockedUsers?: UserUpdateManyWithoutBlockedUsersInput;
  confirmed?: Boolean;
  online?: Boolean;
  friends?: UserUpdateManyWithoutFriendsInput;
  friend_requests?: UserUpdateManyWithoutFriend_requestsInput;
  role?: UserRole;
  channels?: ChannelUpdateManyWithoutMembersInput;
  owned_teams?: TeamUpdateManyWithoutAuthorInput;
  owned_channels?: ChannelUpdateManyWithoutAuthorInput;
}

export interface ChannelUpdateManyWithoutMembersInput {
  create?:
    | ChannelCreateWithoutMembersInput[]
    | ChannelCreateWithoutMembersInput;
  delete?: ChannelWhereUniqueInput[] | ChannelWhereUniqueInput;
  connect?: ChannelWhereUniqueInput[] | ChannelWhereUniqueInput;
  set?: ChannelWhereUniqueInput[] | ChannelWhereUniqueInput;
  disconnect?: ChannelWhereUniqueInput[] | ChannelWhereUniqueInput;
  update?:
    | ChannelUpdateWithWhereUniqueWithoutMembersInput[]
    | ChannelUpdateWithWhereUniqueWithoutMembersInput;
  upsert?:
    | ChannelUpsertWithWhereUniqueWithoutMembersInput[]
    | ChannelUpsertWithWhereUniqueWithoutMembersInput;
  deleteMany?: ChannelScalarWhereInput[] | ChannelScalarWhereInput;
  updateMany?:
    | ChannelUpdateManyWithWhereNestedInput[]
    | ChannelUpdateManyWithWhereNestedInput;
}

export interface ChannelUpdateWithWhereUniqueWithoutMembersInput {
  where: ChannelWhereUniqueInput;
  data: ChannelUpdateWithoutMembersDataInput;
}

export interface ChannelUpdateWithoutMembersDataInput {
  name?: String;
  slug?: String;
  moderators?: UserUpdateManyInput;
  public?: Boolean;
  messages?: MessageUpdateManyInput;
  teamId?: ID_Input;
  author?: UserUpdateOneRequiredWithoutOwned_channelsInput;
}

export interface UserUpdateOneRequiredWithoutOwned_channelsInput {
  create?: UserCreateWithoutOwned_channelsInput;
  update?: UserUpdateWithoutOwned_channelsDataInput;
  upsert?: UserUpsertWithoutOwned_channelsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutOwned_channelsDataInput {
  email?: String;
  notifications?: NotificationUpdateManyInput;
  set_private?: Boolean;
  username?: String;
  password?: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentUpdateManyInput;
  avatar_url?: FileUpdateOneRequiredInput;
  private?: Boolean;
  blockedUsers?: UserUpdateManyWithoutBlockedUsersInput;
  confirmed?: Boolean;
  online?: Boolean;
  friends?: UserUpdateManyWithoutFriendsInput;
  friend_requests?: UserUpdateManyWithoutFriend_requestsInput;
  role?: UserRole;
  teams?: TeamUpdateManyWithoutMembersInput;
  channels?: ChannelUpdateManyWithoutMembersInput;
  owned_teams?: TeamUpdateManyWithoutAuthorInput;
}

export interface UserUpsertWithoutOwned_channelsInput {
  update: UserUpdateWithoutOwned_channelsDataInput;
  create: UserCreateWithoutOwned_channelsInput;
}

export interface ChannelUpsertWithWhereUniqueWithoutMembersInput {
  where: ChannelWhereUniqueInput;
  update: ChannelUpdateWithoutMembersDataInput;
  create: ChannelCreateWithoutMembersInput;
}

export interface ChannelScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  public?: Boolean;
  public_not?: Boolean;
  teamId?: ID_Input;
  teamId_not?: ID_Input;
  teamId_in?: ID_Input[] | ID_Input;
  teamId_not_in?: ID_Input[] | ID_Input;
  teamId_lt?: ID_Input;
  teamId_lte?: ID_Input;
  teamId_gt?: ID_Input;
  teamId_gte?: ID_Input;
  teamId_contains?: ID_Input;
  teamId_not_contains?: ID_Input;
  teamId_starts_with?: ID_Input;
  teamId_not_starts_with?: ID_Input;
  teamId_ends_with?: ID_Input;
  teamId_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ChannelScalarWhereInput[] | ChannelScalarWhereInput;
  OR?: ChannelScalarWhereInput[] | ChannelScalarWhereInput;
  NOT?: ChannelScalarWhereInput[] | ChannelScalarWhereInput;
}

export interface ChannelUpdateManyWithWhereNestedInput {
  where: ChannelScalarWhereInput;
  data: ChannelUpdateManyDataInput;
}

export interface ChannelUpdateManyDataInput {
  name?: String;
  slug?: String;
  public?: Boolean;
  teamId?: ID_Input;
}

export interface ChannelUpdateManyWithoutAuthorInput {
  create?: ChannelCreateWithoutAuthorInput[] | ChannelCreateWithoutAuthorInput;
  delete?: ChannelWhereUniqueInput[] | ChannelWhereUniqueInput;
  connect?: ChannelWhereUniqueInput[] | ChannelWhereUniqueInput;
  set?: ChannelWhereUniqueInput[] | ChannelWhereUniqueInput;
  disconnect?: ChannelWhereUniqueInput[] | ChannelWhereUniqueInput;
  update?:
    | ChannelUpdateWithWhereUniqueWithoutAuthorInput[]
    | ChannelUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | ChannelUpsertWithWhereUniqueWithoutAuthorInput[]
    | ChannelUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: ChannelScalarWhereInput[] | ChannelScalarWhereInput;
  updateMany?:
    | ChannelUpdateManyWithWhereNestedInput[]
    | ChannelUpdateManyWithWhereNestedInput;
}

export interface ChannelUpdateWithWhereUniqueWithoutAuthorInput {
  where: ChannelWhereUniqueInput;
  data: ChannelUpdateWithoutAuthorDataInput;
}

export interface ChannelUpdateWithoutAuthorDataInput {
  name?: String;
  slug?: String;
  moderators?: UserUpdateManyInput;
  public?: Boolean;
  messages?: MessageUpdateManyInput;
  teamId?: ID_Input;
  members?: UserUpdateManyWithoutChannelsInput;
}

export interface ChannelUpsertWithWhereUniqueWithoutAuthorInput {
  where: ChannelWhereUniqueInput;
  update: ChannelUpdateWithoutAuthorDataInput;
  create: ChannelCreateWithoutAuthorInput;
}

export interface UserUpsertWithWhereUniqueWithoutTeamsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutTeamsDataInput;
  create: UserCreateWithoutTeamsInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  set_private?: Boolean;
  set_private_not?: Boolean;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  gitHubId?: ID_Input;
  gitHubId_not?: ID_Input;
  gitHubId_in?: ID_Input[] | ID_Input;
  gitHubId_not_in?: ID_Input[] | ID_Input;
  gitHubId_lt?: ID_Input;
  gitHubId_lte?: ID_Input;
  gitHubId_gt?: ID_Input;
  gitHubId_gte?: ID_Input;
  gitHubId_contains?: ID_Input;
  gitHubId_not_contains?: ID_Input;
  gitHubId_starts_with?: ID_Input;
  gitHubId_not_starts_with?: ID_Input;
  gitHubId_ends_with?: ID_Input;
  gitHubId_not_ends_with?: ID_Input;
  facebookId?: ID_Input;
  facebookId_not?: ID_Input;
  facebookId_in?: ID_Input[] | ID_Input;
  facebookId_not_in?: ID_Input[] | ID_Input;
  facebookId_lt?: ID_Input;
  facebookId_lte?: ID_Input;
  facebookId_gt?: ID_Input;
  facebookId_gte?: ID_Input;
  facebookId_contains?: ID_Input;
  facebookId_not_contains?: ID_Input;
  facebookId_starts_with?: ID_Input;
  facebookId_not_starts_with?: ID_Input;
  facebookId_ends_with?: ID_Input;
  facebookId_not_ends_with?: ID_Input;
  twitterId?: ID_Input;
  twitterId_not?: ID_Input;
  twitterId_in?: ID_Input[] | ID_Input;
  twitterId_not_in?: ID_Input[] | ID_Input;
  twitterId_lt?: ID_Input;
  twitterId_lte?: ID_Input;
  twitterId_gt?: ID_Input;
  twitterId_gte?: ID_Input;
  twitterId_contains?: ID_Input;
  twitterId_not_contains?: ID_Input;
  twitterId_starts_with?: ID_Input;
  twitterId_not_starts_with?: ID_Input;
  twitterId_ends_with?: ID_Input;
  twitterId_not_ends_with?: ID_Input;
  gmailId?: String;
  gmailId_not?: String;
  gmailId_in?: String[] | String;
  gmailId_not_in?: String[] | String;
  gmailId_lt?: String;
  gmailId_lte?: String;
  gmailId_gt?: String;
  gmailId_gte?: String;
  gmailId_contains?: String;
  gmailId_not_contains?: String;
  gmailId_starts_with?: String;
  gmailId_not_starts_with?: String;
  gmailId_ends_with?: String;
  gmailId_not_ends_with?: String;
  private?: Boolean;
  private_not?: Boolean;
  confirmed?: Boolean;
  confirmed_not?: Boolean;
  online?: Boolean;
  online_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  role?: UserRole;
  role_not?: UserRole;
  role_in?: UserRole[] | UserRole;
  role_not_in?: UserRole[] | UserRole;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  email?: String;
  set_private?: Boolean;
  username?: String;
  password?: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  private?: Boolean;
  confirmed?: Boolean;
  online?: Boolean;
  role?: UserRole;
}

export interface TeamUpsertWithWhereUniqueWithoutAuthorInput {
  where: TeamWhereUniqueInput;
  update: TeamUpdateWithoutAuthorDataInput;
  create: TeamCreateWithoutAuthorInput;
}

export interface TeamScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  confirmed?: Boolean;
  confirmed_not?: Boolean;
  online?: Boolean;
  online_not?: Boolean;
  AND?: TeamScalarWhereInput[] | TeamScalarWhereInput;
  OR?: TeamScalarWhereInput[] | TeamScalarWhereInput;
  NOT?: TeamScalarWhereInput[] | TeamScalarWhereInput;
}

export interface TeamUpdateManyWithWhereNestedInput {
  where: TeamScalarWhereInput;
  data: TeamUpdateManyDataInput;
}

export interface TeamUpdateManyDataInput {
  name?: String;
  slug?: String;
  confirmed?: Boolean;
  online?: Boolean;
}

export interface UserUpsertWithWhereUniqueWithoutChannelsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutChannelsDataInput;
  create: UserCreateWithoutChannelsInput;
}

export interface ChannelUpsertWithWhereUniqueNestedInput {
  where: ChannelWhereUniqueInput;
  update: ChannelUpdateDataInput;
  create: ChannelCreateInput;
}

export interface TeamUpsertWithWhereUniqueWithoutMembersInput {
  where: TeamWhereUniqueInput;
  update: TeamUpdateWithoutMembersDataInput;
  create: TeamCreateWithoutMembersInput;
}

export interface UserUpsertWithWhereUniqueWithoutFriend_requestsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutFriend_requestsDataInput;
  create: UserCreateWithoutFriend_requestsInput;
}

export interface UserUpsertWithWhereUniqueWithoutFriendsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutFriendsDataInput;
  create: UserCreateWithoutFriendsInput;
}

export interface UserUpsertWithWhereUniqueWithoutBlockedUsersInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutBlockedUsersDataInput;
  create: UserCreateWithoutBlockedUsersInput;
}

export interface UserUpsertWithoutOwned_teamsInput {
  update: UserUpdateWithoutOwned_teamsDataInput;
  create: UserCreateWithoutOwned_teamsInput;
}

export interface TeamUpsertNestedInput {
  update: TeamUpdateDataInput;
  create: TeamCreateInput;
}

export interface ChannelUpdateOneInput {
  create?: ChannelCreateInput;
  update?: ChannelUpdateDataInput;
  upsert?: ChannelUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ChannelWhereUniqueInput;
}

export interface ChannelUpsertNestedInput {
  update: ChannelUpdateDataInput;
  create: ChannelCreateInput;
}

export interface NotificationUpsertWithWhereUniqueNestedInput {
  where: NotificationWhereUniqueInput;
  update: NotificationUpdateDataInput;
  create: NotificationCreateInput;
}

export interface NotificationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  message?: String;
  message_not?: String;
  message_in?: String[] | String;
  message_not_in?: String[] | String;
  message_lt?: String;
  message_lte?: String;
  message_gt?: String;
  message_gte?: String;
  message_contains?: String;
  message_not_contains?: String;
  message_starts_with?: String;
  message_not_starts_with?: String;
  message_ends_with?: String;
  message_not_ends_with?: String;
  AND?: NotificationScalarWhereInput[] | NotificationScalarWhereInput;
  OR?: NotificationScalarWhereInput[] | NotificationScalarWhereInput;
  NOT?: NotificationScalarWhereInput[] | NotificationScalarWhereInput;
}

export interface NotificationUpdateManyWithWhereNestedInput {
  where: NotificationScalarWhereInput;
  data: NotificationUpdateManyDataInput;
}

export interface NotificationUpdateManyDataInput {
  message?: String;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ChannelUpdateManyMutationInput {
  name?: String;
  slug?: String;
  public?: Boolean;
  teamId?: ID_Input;
}

export interface CommentUpdateInput {
  body?: String;
  parentId?: ID_Input;
  pageId?: ID_Input;
  repliedTo?: UserUpdateOneInput;
  ratings?: RatingUpdateOneRequiredInput;
  replies?: CommentUpdateManyWithoutRepliesInput;
  author?: UserUpdateOneRequiredInput;
}

export interface CommentUpdateManyMutationInput {
  body?: String;
  parentId?: ID_Input;
  pageId?: ID_Input;
}

export interface CommentOptionsCreateInput {
  comments_open: Boolean;
}

export interface CommentOptionsUpdateManyMutationInput {
  comments_open?: Boolean;
}

export interface CommentSectionCreateInput {
  comments?: CommentCreateManyInput;
  pageId: ID_Input;
  url: String;
  admin: UserCreateOneInput;
  moderators?: ModeratorCreateManyInput;
  options: CommentOptionsCreateOneInput;
  bannedUsers?: UserCreateManyInput;
}

export interface ModeratorCreateManyInput {
  create?: ModeratorCreateInput[] | ModeratorCreateInput;
  connect?: ModeratorWhereUniqueInput[] | ModeratorWhereUniqueInput;
}

export interface ModeratorCreateInput {
  user: UserCreateOneInput;
  can_delete: Boolean;
  can_ban: Boolean;
  can_edit: Boolean;
  can_close: Boolean;
}

export interface CommentOptionsCreateOneInput {
  create?: CommentOptionsCreateInput;
}

export interface CommentSectionUpdateInput {
  comments?: CommentUpdateManyInput;
  pageId?: ID_Input;
  url?: String;
  admin?: UserUpdateOneRequiredInput;
  moderators?: ModeratorUpdateManyInput;
  options?: CommentOptionsUpdateOneRequiredInput;
  bannedUsers?: UserUpdateManyInput;
}

export interface ModeratorUpdateManyInput {
  create?: ModeratorCreateInput[] | ModeratorCreateInput;
  update?:
    | ModeratorUpdateWithWhereUniqueNestedInput[]
    | ModeratorUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ModeratorUpsertWithWhereUniqueNestedInput[]
    | ModeratorUpsertWithWhereUniqueNestedInput;
  delete?: ModeratorWhereUniqueInput[] | ModeratorWhereUniqueInput;
  connect?: ModeratorWhereUniqueInput[] | ModeratorWhereUniqueInput;
  set?: ModeratorWhereUniqueInput[] | ModeratorWhereUniqueInput;
  disconnect?: ModeratorWhereUniqueInput[] | ModeratorWhereUniqueInput;
  deleteMany?: ModeratorScalarWhereInput[] | ModeratorScalarWhereInput;
  updateMany?:
    | ModeratorUpdateManyWithWhereNestedInput[]
    | ModeratorUpdateManyWithWhereNestedInput;
}

export interface ModeratorUpdateWithWhereUniqueNestedInput {
  where: ModeratorWhereUniqueInput;
  data: ModeratorUpdateDataInput;
}

export interface ModeratorUpdateDataInput {
  user?: UserUpdateOneRequiredInput;
  can_delete?: Boolean;
  can_ban?: Boolean;
  can_edit?: Boolean;
  can_close?: Boolean;
}

export interface ModeratorUpsertWithWhereUniqueNestedInput {
  where: ModeratorWhereUniqueInput;
  update: ModeratorUpdateDataInput;
  create: ModeratorCreateInput;
}

export interface ModeratorScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  can_delete?: Boolean;
  can_delete_not?: Boolean;
  can_ban?: Boolean;
  can_ban_not?: Boolean;
  can_edit?: Boolean;
  can_edit_not?: Boolean;
  can_close?: Boolean;
  can_close_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ModeratorScalarWhereInput[] | ModeratorScalarWhereInput;
  OR?: ModeratorScalarWhereInput[] | ModeratorScalarWhereInput;
  NOT?: ModeratorScalarWhereInput[] | ModeratorScalarWhereInput;
}

export interface ModeratorUpdateManyWithWhereNestedInput {
  where: ModeratorScalarWhereInput;
  data: ModeratorUpdateManyDataInput;
}

export interface ModeratorUpdateManyDataInput {
  can_delete?: Boolean;
  can_ban?: Boolean;
  can_edit?: Boolean;
  can_close?: Boolean;
}

export interface CommentOptionsUpdateOneRequiredInput {
  create?: CommentOptionsCreateInput;
  update?: CommentOptionsUpdateDataInput;
  upsert?: CommentOptionsUpsertNestedInput;
}

export interface CommentOptionsUpdateDataInput {
  comments_open?: Boolean;
}

export interface CommentOptionsUpsertNestedInput {
  update: CommentOptionsUpdateDataInput;
  create: CommentOptionsCreateInput;
}

export interface CommentSectionUpdateManyMutationInput {
  pageId?: ID_Input;
  url?: String;
}

export interface CustomerCreateInput {
  user: UserCreateOneInput;
  stripeId: ID_Input;
}

export interface CustomerUpdateInput {
  user?: UserUpdateOneRequiredInput;
  stripeId?: ID_Input;
}

export interface CustomerUpdateManyMutationInput {
  stripeId?: ID_Input;
}

export interface FileUpdateInput {
  filename?: String;
  mimetype?: String;
  encoding?: String;
  key?: String;
  ETag?: String;
  url?: String;
}

export interface FileUpdateManyMutationInput {
  filename?: String;
  mimetype?: String;
  encoding?: String;
  key?: String;
  ETag?: String;
  url?: String;
}

export interface MessageUpdateInput {
  body?: String;
  parentId?: ID_Input;
  url?: String;
  filetype?: String;
  author?: UserUpdateOneRequiredInput;
}

export interface MessageUpdateManyMutationInput {
  body?: String;
  parentId?: ID_Input;
  url?: String;
  filetype?: String;
}

export interface ModeratorUpdateInput {
  user?: UserUpdateOneRequiredInput;
  can_delete?: Boolean;
  can_ban?: Boolean;
  can_edit?: Boolean;
  can_close?: Boolean;
}

export interface ModeratorUpdateManyMutationInput {
  can_delete?: Boolean;
  can_ban?: Boolean;
  can_edit?: Boolean;
  can_close?: Boolean;
}

export interface NotificationUpdateInput {
  message?: String;
  comments?: CommentUpdateOneInput;
  messages?: MessageUpdateOneInput;
  team?: TeamUpdateOneInput;
  channel?: ChannelUpdateOneInput;
  friend_requests?: UserUpdateOneInput;
  friend?: UserUpdateOneInput;
  author?: UserUpdateOneRequiredInput;
}

export interface NotificationUpdateManyMutationInput {
  message?: String;
}

export interface OrderCreateInput {
  products?: ProductCreateManyInput;
  customer: CustomerCreateOneInput;
  total_price: Float;
  confirmed: Boolean;
  currency: String;
}

export interface ProductCreateManyInput {
  create?: ProductCreateInput[] | ProductCreateInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface ProductCreateInput {
  name: String;
  stock: Int;
  price: Float;
}

export interface CustomerCreateOneInput {
  create?: CustomerCreateInput;
  connect?: CustomerWhereUniqueInput;
}

export interface OrderUpdateInput {
  products?: ProductUpdateManyInput;
  customer?: CustomerUpdateOneRequiredInput;
  total_price?: Float;
  confirmed?: Boolean;
  currency?: String;
}

export interface ProductUpdateManyInput {
  create?: ProductCreateInput[] | ProductCreateInput;
  update?:
    | ProductUpdateWithWhereUniqueNestedInput[]
    | ProductUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ProductUpsertWithWhereUniqueNestedInput[]
    | ProductUpsertWithWhereUniqueNestedInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  set?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface ProductUpdateWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateDataInput;
}

export interface ProductUpdateDataInput {
  name?: String;
  stock?: Int;
  price?: Float;
}

export interface ProductUpsertWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface ProductScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  stock?: Int;
  stock_not?: Int;
  stock_in?: Int[] | Int;
  stock_not_in?: Int[] | Int;
  stock_lt?: Int;
  stock_lte?: Int;
  stock_gt?: Int;
  stock_gte?: Int;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  OR?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  NOT?: ProductScalarWhereInput[] | ProductScalarWhereInput;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface ProductUpdateManyDataInput {
  name?: String;
  stock?: Int;
  price?: Float;
}

export interface CustomerUpdateOneRequiredInput {
  create?: CustomerCreateInput;
  update?: CustomerUpdateDataInput;
  upsert?: CustomerUpsertNestedInput;
  connect?: CustomerWhereUniqueInput;
}

export interface CustomerUpdateDataInput {
  user?: UserUpdateOneRequiredInput;
  stripeId?: ID_Input;
}

export interface CustomerUpsertNestedInput {
  update: CustomerUpdateDataInput;
  create: CustomerCreateInput;
}

export interface OrderUpdateManyMutationInput {
  total_price?: Float;
  confirmed?: Boolean;
  currency?: String;
}

export interface ProductUpdateInput {
  name?: String;
  stock?: Int;
  price?: Float;
}

export interface ProductUpdateManyMutationInput {
  name?: String;
  stock?: Int;
  price?: Float;
}

export interface RatingUpdateInput {
  vote?: Int;
  author?: UserUpdateManyInput;
}

export interface RatingUpdateManyMutationInput {
  vote?: Int;
}

export interface TeamUpdateInput {
  name?: String;
  slug?: String;
  moderators?: UserUpdateManyInput;
  author?: UserUpdateOneRequiredWithoutOwned_teamsInput;
  members?: UserUpdateManyWithoutTeamsInput;
  channels?: ChannelUpdateManyInput;
  confirmed?: Boolean;
  online?: Boolean;
}

export interface TeamUpdateManyMutationInput {
  name?: String;
  slug?: String;
  confirmed?: Boolean;
  online?: Boolean;
}

export interface TeamSettingCreateInput {
  cankick: Boolean;
}

export interface TeamSettingUpdateInput {
  cankick?: Boolean;
}

export interface TeamSettingUpdateManyMutationInput {
  cankick?: Boolean;
}

export interface TodoCreateInput {
  body: String;
  author: UserCreateOneInput;
}

export interface TodoUpdateInput {
  body?: String;
  author?: UserUpdateOneRequiredInput;
}

export interface TodoUpdateManyMutationInput {
  body?: String;
}

export interface TodoProjectCreateInput {
  name: String;
  todos?: TodoCreateManyInput;
  author: UserCreateOneInput;
}

export interface TodoCreateManyInput {
  create?: TodoCreateInput[] | TodoCreateInput;
  connect?: TodoWhereUniqueInput[] | TodoWhereUniqueInput;
}

export interface TodoProjectUpdateInput {
  name?: String;
  todos?: TodoUpdateManyInput;
  author?: UserUpdateOneRequiredInput;
}

export interface TodoUpdateManyInput {
  create?: TodoCreateInput[] | TodoCreateInput;
  update?:
    | TodoUpdateWithWhereUniqueNestedInput[]
    | TodoUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TodoUpsertWithWhereUniqueNestedInput[]
    | TodoUpsertWithWhereUniqueNestedInput;
  delete?: TodoWhereUniqueInput[] | TodoWhereUniqueInput;
  connect?: TodoWhereUniqueInput[] | TodoWhereUniqueInput;
  set?: TodoWhereUniqueInput[] | TodoWhereUniqueInput;
  disconnect?: TodoWhereUniqueInput[] | TodoWhereUniqueInput;
  deleteMany?: TodoScalarWhereInput[] | TodoScalarWhereInput;
  updateMany?:
    | TodoUpdateManyWithWhereNestedInput[]
    | TodoUpdateManyWithWhereNestedInput;
}

export interface TodoUpdateWithWhereUniqueNestedInput {
  where: TodoWhereUniqueInput;
  data: TodoUpdateDataInput;
}

export interface TodoUpdateDataInput {
  body?: String;
  author?: UserUpdateOneRequiredInput;
}

export interface TodoUpsertWithWhereUniqueNestedInput {
  where: TodoWhereUniqueInput;
  update: TodoUpdateDataInput;
  create: TodoCreateInput;
}

export interface TodoScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  body?: String;
  body_not?: String;
  body_in?: String[] | String;
  body_not_in?: String[] | String;
  body_lt?: String;
  body_lte?: String;
  body_gt?: String;
  body_gte?: String;
  body_contains?: String;
  body_not_contains?: String;
  body_starts_with?: String;
  body_not_starts_with?: String;
  body_ends_with?: String;
  body_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: TodoScalarWhereInput[] | TodoScalarWhereInput;
  OR?: TodoScalarWhereInput[] | TodoScalarWhereInput;
  NOT?: TodoScalarWhereInput[] | TodoScalarWhereInput;
}

export interface TodoUpdateManyWithWhereNestedInput {
  where: TodoScalarWhereInput;
  data: TodoUpdateManyDataInput;
}

export interface TodoUpdateManyDataInput {
  body?: String;
}

export interface TodoProjectUpdateManyMutationInput {
  name?: String;
}

export interface UserUpdateInput {
  email?: String;
  notifications?: NotificationUpdateManyInput;
  set_private?: Boolean;
  username?: String;
  password?: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  directMessages?: CommentUpdateManyInput;
  avatar_url?: FileUpdateOneRequiredInput;
  private?: Boolean;
  blockedUsers?: UserUpdateManyWithoutBlockedUsersInput;
  confirmed?: Boolean;
  online?: Boolean;
  friends?: UserUpdateManyWithoutFriendsInput;
  friend_requests?: UserUpdateManyWithoutFriend_requestsInput;
  role?: UserRole;
  teams?: TeamUpdateManyWithoutMembersInput;
  channels?: ChannelUpdateManyWithoutMembersInput;
  owned_teams?: TeamUpdateManyWithoutAuthorInput;
  owned_channels?: ChannelUpdateManyWithoutAuthorInput;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  set_private?: Boolean;
  username?: String;
  password?: String;
  gitHubId?: ID_Input;
  facebookId?: ID_Input;
  twitterId?: ID_Input;
  gmailId?: String;
  private?: Boolean;
  confirmed?: Boolean;
  online?: Boolean;
  role?: UserRole;
}

export interface ChannelSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ChannelWhereInput;
  AND?: ChannelSubscriptionWhereInput[] | ChannelSubscriptionWhereInput;
  OR?: ChannelSubscriptionWhereInput[] | ChannelSubscriptionWhereInput;
  NOT?: ChannelSubscriptionWhereInput[] | ChannelSubscriptionWhereInput;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommentWhereInput;
  AND?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  OR?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  NOT?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
}

export interface CommentOptionsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommentOptionsWhereInput;
  AND?:
    | CommentOptionsSubscriptionWhereInput[]
    | CommentOptionsSubscriptionWhereInput;
  OR?:
    | CommentOptionsSubscriptionWhereInput[]
    | CommentOptionsSubscriptionWhereInput;
  NOT?:
    | CommentOptionsSubscriptionWhereInput[]
    | CommentOptionsSubscriptionWhereInput;
}

export interface CommentSectionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommentSectionWhereInput;
  AND?:
    | CommentSectionSubscriptionWhereInput[]
    | CommentSectionSubscriptionWhereInput;
  OR?:
    | CommentSectionSubscriptionWhereInput[]
    | CommentSectionSubscriptionWhereInput;
  NOT?:
    | CommentSectionSubscriptionWhereInput[]
    | CommentSectionSubscriptionWhereInput;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CustomerWhereInput;
  AND?: CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput;
  OR?: CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput;
  NOT?: CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FileWhereInput;
  AND?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  OR?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  NOT?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MessageWhereInput;
  AND?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
  OR?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
  NOT?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
}

export interface ModeratorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ModeratorWhereInput;
  AND?: ModeratorSubscriptionWhereInput[] | ModeratorSubscriptionWhereInput;
  OR?: ModeratorSubscriptionWhereInput[] | ModeratorSubscriptionWhereInput;
  NOT?: ModeratorSubscriptionWhereInput[] | ModeratorSubscriptionWhereInput;
}

export interface NotificationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NotificationWhereInput;
  AND?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
  OR?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
  NOT?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrderWhereInput;
  AND?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  OR?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  NOT?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductWhereInput;
  AND?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  OR?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  NOT?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
}

export interface RatingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RatingWhereInput;
  AND?: RatingSubscriptionWhereInput[] | RatingSubscriptionWhereInput;
  OR?: RatingSubscriptionWhereInput[] | RatingSubscriptionWhereInput;
  NOT?: RatingSubscriptionWhereInput[] | RatingSubscriptionWhereInput;
}

export interface TeamSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TeamWhereInput;
  AND?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
  OR?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
  NOT?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
}

export interface TeamSettingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TeamSettingWhereInput;
  AND?: TeamSettingSubscriptionWhereInput[] | TeamSettingSubscriptionWhereInput;
  OR?: TeamSettingSubscriptionWhereInput[] | TeamSettingSubscriptionWhereInput;
  NOT?: TeamSettingSubscriptionWhereInput[] | TeamSettingSubscriptionWhereInput;
}

export interface TodoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TodoWhereInput;
  AND?: TodoSubscriptionWhereInput[] | TodoSubscriptionWhereInput;
  OR?: TodoSubscriptionWhereInput[] | TodoSubscriptionWhereInput;
  NOT?: TodoSubscriptionWhereInput[] | TodoSubscriptionWhereInput;
}

export interface TodoProjectSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TodoProjectWhereInput;
  AND?: TodoProjectSubscriptionWhereInput[] | TodoProjectSubscriptionWhereInput;
  OR?: TodoProjectSubscriptionWhereInput[] | TodoProjectSubscriptionWhereInput;
  NOT?: TodoProjectSubscriptionWhereInput[] | TodoProjectSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Channel {
  id: ID_Output;
  name: String;
  slug: String;
  public?: Boolean;
  teamId: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ChannelPromise extends Promise<Channel>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  moderators: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  public: () => Promise<Boolean>;
  messages: <T = FragmentableArray<Message>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  teamId: () => Promise<ID_Output>;
  members: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  author: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ChannelSubscription
  extends Promise<AsyncIterator<Channel>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  moderators: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  public: () => Promise<AsyncIterator<Boolean>>;
  messages: <T = Promise<AsyncIterator<MessageSubscription>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  teamId: () => Promise<AsyncIterator<ID_Output>>;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  author: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface User {
  id: ID_Output;
  email?: String;
  set_private: Boolean;
  username: String;
  password: String;
  gitHubId?: ID_Output;
  facebookId?: ID_Output;
  twitterId?: ID_Output;
  gmailId?: String;
  private: Boolean;
  confirmed: Boolean;
  online: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  role: UserRole;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  notifications: <T = FragmentableArray<Notification>>(
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  set_private: () => Promise<Boolean>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  gitHubId: () => Promise<ID_Output>;
  facebookId: () => Promise<ID_Output>;
  twitterId: () => Promise<ID_Output>;
  gmailId: () => Promise<String>;
  directMessages: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  avatar_url: <T = FilePromise>() => T;
  private: () => Promise<Boolean>;
  blockedUsers: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  confirmed: () => Promise<Boolean>;
  online: () => Promise<Boolean>;
  friends: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  friend_requests: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  role: () => Promise<UserRole>;
  teams: <T = FragmentableArray<Team>>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  channels: <T = FragmentableArray<Channel>>(
    args?: {
      where?: ChannelWhereInput;
      orderBy?: ChannelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owned_teams: <T = FragmentableArray<Team>>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owned_channels: <T = FragmentableArray<Channel>>(
    args?: {
      where?: ChannelWhereInput;
      orderBy?: ChannelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  notifications: <T = Promise<AsyncIterator<NotificationSubscription>>>(
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  set_private: () => Promise<AsyncIterator<Boolean>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  gitHubId: () => Promise<AsyncIterator<ID_Output>>;
  facebookId: () => Promise<AsyncIterator<ID_Output>>;
  twitterId: () => Promise<AsyncIterator<ID_Output>>;
  gmailId: () => Promise<AsyncIterator<String>>;
  directMessages: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  avatar_url: <T = FileSubscription>() => T;
  private: () => Promise<AsyncIterator<Boolean>>;
  blockedUsers: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  confirmed: () => Promise<AsyncIterator<Boolean>>;
  online: () => Promise<AsyncIterator<Boolean>>;
  friends: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  friend_requests: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  teams: <T = Promise<AsyncIterator<TeamSubscription>>>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  channels: <T = Promise<AsyncIterator<ChannelSubscription>>>(
    args?: {
      where?: ChannelWhereInput;
      orderBy?: ChannelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owned_teams: <T = Promise<AsyncIterator<TeamSubscription>>>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owned_channels: <T = Promise<AsyncIterator<ChannelSubscription>>>(
    args?: {
      where?: ChannelWhereInput;
      orderBy?: ChannelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Notification {
  id: ID_Output;
  message?: String;
}

export interface NotificationPromise
  extends Promise<Notification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
  comments: <T = CommentPromise>() => T;
  messages: <T = MessagePromise>() => T;
  team: <T = TeamPromise>() => T;
  channel: <T = ChannelPromise>() => T;
  friend_requests: <T = UserPromise>() => T;
  friend: <T = UserPromise>() => T;
  author: <T = UserPromise>() => T;
}

export interface NotificationSubscription
  extends Promise<AsyncIterator<Notification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
  comments: <T = CommentSubscription>() => T;
  messages: <T = MessageSubscription>() => T;
  team: <T = TeamSubscription>() => T;
  channel: <T = ChannelSubscription>() => T;
  friend_requests: <T = UserSubscription>() => T;
  friend: <T = UserSubscription>() => T;
  author: <T = UserSubscription>() => T;
}

export interface Comment {
  id: ID_Output;
  body: String;
  parentId: ID_Output;
  pageId: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  body: () => Promise<String>;
  parentId: () => Promise<ID_Output>;
  pageId: () => Promise<ID_Output>;
  repliedTo: <T = UserPromise>() => T;
  ratings: <T = RatingPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  replies: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  author: <T = UserPromise>() => T;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  body: () => Promise<AsyncIterator<String>>;
  parentId: () => Promise<AsyncIterator<ID_Output>>;
  pageId: () => Promise<AsyncIterator<ID_Output>>;
  repliedTo: <T = UserSubscription>() => T;
  ratings: <T = RatingSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  replies: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  author: <T = UserSubscription>() => T;
}

export interface Rating {
  id: ID_Output;
  vote: Int;
}

export interface RatingPromise extends Promise<Rating>, Fragmentable {
  id: () => Promise<ID_Output>;
  vote: () => Promise<Int>;
  author: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface RatingSubscription
  extends Promise<AsyncIterator<Rating>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  vote: () => Promise<AsyncIterator<Int>>;
  author: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Message {
  id: ID_Output;
  body: String;
  parentId: ID_Output;
  url: String;
  filetype: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
  id: () => Promise<ID_Output>;
  body: () => Promise<String>;
  parentId: () => Promise<ID_Output>;
  url: () => Promise<String>;
  filetype: () => Promise<String>;
  author: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MessageSubscription
  extends Promise<AsyncIterator<Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  body: () => Promise<AsyncIterator<String>>;
  parentId: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  filetype: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Team {
  id: ID_Output;
  name: String;
  slug: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  confirmed: Boolean;
  online: Boolean;
}

export interface TeamPromise extends Promise<Team>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  moderators: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  author: <T = UserPromise>() => T;
  members: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  channels: <T = FragmentableArray<Channel>>(
    args?: {
      where?: ChannelWhereInput;
      orderBy?: ChannelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  confirmed: () => Promise<Boolean>;
  online: () => Promise<Boolean>;
}

export interface TeamSubscription
  extends Promise<AsyncIterator<Team>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  moderators: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  author: <T = UserSubscription>() => T;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  channels: <T = Promise<AsyncIterator<ChannelSubscription>>>(
    args?: {
      where?: ChannelWhereInput;
      orderBy?: ChannelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  confirmed: () => Promise<AsyncIterator<Boolean>>;
  online: () => Promise<AsyncIterator<Boolean>>;
}

export interface File {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  filename: String;
  mimetype: String;
  encoding: String;
  key: String;
  ETag: String;
  url: String;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  filename: () => Promise<String>;
  mimetype: () => Promise<String>;
  encoding: () => Promise<String>;
  key: () => Promise<String>;
  ETag: () => Promise<String>;
  url: () => Promise<String>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  filename: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  encoding: () => Promise<AsyncIterator<String>>;
  key: () => Promise<AsyncIterator<String>>;
  ETag: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface ChannelConnection {
  pageInfo: PageInfo;
  edges: ChannelEdge[];
}

export interface ChannelConnectionPromise
  extends Promise<ChannelConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChannelEdge>>() => T;
  aggregate: <T = AggregateChannelPromise>() => T;
}

export interface ChannelConnectionSubscription
  extends Promise<AsyncIterator<ChannelConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChannelEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChannelSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ChannelEdge {
  node: Channel;
  cursor: String;
}

export interface ChannelEdgePromise extends Promise<ChannelEdge>, Fragmentable {
  node: <T = ChannelPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChannelEdgeSubscription
  extends Promise<AsyncIterator<ChannelEdge>>,
    Fragmentable {
  node: <T = ChannelSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChannel {
  count: Int;
}

export interface AggregateChannelPromise
  extends Promise<AggregateChannel>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChannelSubscription
  extends Promise<AsyncIterator<AggregateChannel>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentOptions {
  comments_open: Boolean;
}

export interface CommentOptionsPromise
  extends Promise<CommentOptions>,
    Fragmentable {
  comments_open: () => Promise<Boolean>;
}

export interface CommentOptionsSubscription
  extends Promise<AsyncIterator<CommentOptions>>,
    Fragmentable {
  comments_open: () => Promise<AsyncIterator<Boolean>>;
}

export interface CommentOptionsConnection {
  pageInfo: PageInfo;
  edges: CommentOptionsEdge[];
}

export interface CommentOptionsConnectionPromise
  extends Promise<CommentOptionsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentOptionsEdge>>() => T;
  aggregate: <T = AggregateCommentOptionsPromise>() => T;
}

export interface CommentOptionsConnectionSubscription
  extends Promise<AsyncIterator<CommentOptionsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentOptionsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentOptionsSubscription>() => T;
}

export interface CommentOptionsEdge {
  node: CommentOptions;
  cursor: String;
}

export interface CommentOptionsEdgePromise
  extends Promise<CommentOptionsEdge>,
    Fragmentable {
  node: <T = CommentOptionsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentOptionsEdgeSubscription
  extends Promise<AsyncIterator<CommentOptionsEdge>>,
    Fragmentable {
  node: <T = CommentOptionsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCommentOptions {
  count: Int;
}

export interface AggregateCommentOptionsPromise
  extends Promise<AggregateCommentOptions>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentOptionsSubscription
  extends Promise<AsyncIterator<AggregateCommentOptions>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentSection {
  id: ID_Output;
  pageId: ID_Output;
  url: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentSectionPromise
  extends Promise<CommentSection>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pageId: () => Promise<ID_Output>;
  url: () => Promise<String>;
  admin: <T = UserPromise>() => T;
  moderators: <T = FragmentableArray<Moderator>>(
    args?: {
      where?: ModeratorWhereInput;
      orderBy?: ModeratorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  options: <T = CommentOptionsPromise>() => T;
  bannedUsers: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentSectionSubscription
  extends Promise<AsyncIterator<CommentSection>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pageId: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  admin: <T = UserSubscription>() => T;
  moderators: <T = Promise<AsyncIterator<ModeratorSubscription>>>(
    args?: {
      where?: ModeratorWhereInput;
      orderBy?: ModeratorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  options: <T = CommentOptionsSubscription>() => T;
  bannedUsers: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Moderator {
  id: ID_Output;
  can_delete: Boolean;
  can_ban: Boolean;
  can_edit: Boolean;
  can_close: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ModeratorPromise extends Promise<Moderator>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  can_delete: () => Promise<Boolean>;
  can_ban: () => Promise<Boolean>;
  can_edit: () => Promise<Boolean>;
  can_close: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ModeratorSubscription
  extends Promise<AsyncIterator<Moderator>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  can_delete: () => Promise<AsyncIterator<Boolean>>;
  can_ban: () => Promise<AsyncIterator<Boolean>>;
  can_edit: () => Promise<AsyncIterator<Boolean>>;
  can_close: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentSectionConnection {
  pageInfo: PageInfo;
  edges: CommentSectionEdge[];
}

export interface CommentSectionConnectionPromise
  extends Promise<CommentSectionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentSectionEdge>>() => T;
  aggregate: <T = AggregateCommentSectionPromise>() => T;
}

export interface CommentSectionConnectionSubscription
  extends Promise<AsyncIterator<CommentSectionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentSectionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSectionSubscription>() => T;
}

export interface CommentSectionEdge {
  node: CommentSection;
  cursor: String;
}

export interface CommentSectionEdgePromise
  extends Promise<CommentSectionEdge>,
    Fragmentable {
  node: <T = CommentSectionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentSectionEdgeSubscription
  extends Promise<AsyncIterator<CommentSectionEdge>>,
    Fragmentable {
  node: <T = CommentSectionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCommentSection {
  count: Int;
}

export interface AggregateCommentSectionPromise
  extends Promise<AggregateCommentSection>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSectionSubscription
  extends Promise<AsyncIterator<AggregateCommentSection>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Customer {
  id: ID_Output;
  stripeId: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  stripeId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  stripeId: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessageConnection {
  pageInfo: PageInfo;
  edges: MessageEdge[];
}

export interface MessageConnectionPromise
  extends Promise<MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MessageEdge>>() => T;
  aggregate: <T = AggregateMessagePromise>() => T;
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface MessageEdge {
  node: Message;
  cursor: String;
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
  node: <T = MessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdge>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMessage {
  count: Int;
}

export interface AggregateMessagePromise
  extends Promise<AggregateMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ModeratorConnection {
  pageInfo: PageInfo;
  edges: ModeratorEdge[];
}

export interface ModeratorConnectionPromise
  extends Promise<ModeratorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ModeratorEdge>>() => T;
  aggregate: <T = AggregateModeratorPromise>() => T;
}

export interface ModeratorConnectionSubscription
  extends Promise<AsyncIterator<ModeratorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ModeratorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateModeratorSubscription>() => T;
}

export interface ModeratorEdge {
  node: Moderator;
  cursor: String;
}

export interface ModeratorEdgePromise
  extends Promise<ModeratorEdge>,
    Fragmentable {
  node: <T = ModeratorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ModeratorEdgeSubscription
  extends Promise<AsyncIterator<ModeratorEdge>>,
    Fragmentable {
  node: <T = ModeratorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateModerator {
  count: Int;
}

export interface AggregateModeratorPromise
  extends Promise<AggregateModerator>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateModeratorSubscription
  extends Promise<AsyncIterator<AggregateModerator>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NotificationConnection {
  pageInfo: PageInfo;
  edges: NotificationEdge[];
}

export interface NotificationConnectionPromise
  extends Promise<NotificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NotificationEdge>>() => T;
  aggregate: <T = AggregateNotificationPromise>() => T;
}

export interface NotificationConnectionSubscription
  extends Promise<AsyncIterator<NotificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NotificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNotificationSubscription>() => T;
}

export interface NotificationEdge {
  node: Notification;
  cursor: String;
}

export interface NotificationEdgePromise
  extends Promise<NotificationEdge>,
    Fragmentable {
  node: <T = NotificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NotificationEdgeSubscription
  extends Promise<AsyncIterator<NotificationEdge>>,
    Fragmentable {
  node: <T = NotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNotification {
  count: Int;
}

export interface AggregateNotificationPromise
  extends Promise<AggregateNotification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNotificationSubscription
  extends Promise<AsyncIterator<AggregateNotification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Order {
  id: ID_Output;
  total_price: Float;
  confirmed: Boolean;
  currency: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<ID_Output>;
  products: <T = FragmentableArray<Product>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  customer: <T = CustomerPromise>() => T;
  total_price: () => Promise<Float>;
  confirmed: () => Promise<Boolean>;
  currency: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  customer: <T = CustomerSubscription>() => T;
  total_price: () => Promise<AsyncIterator<Float>>;
  confirmed: () => Promise<AsyncIterator<Boolean>>;
  currency: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Product {
  id: ID_Output;
  name: String;
  stock: Int;
  price: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  stock: () => Promise<Int>;
  price: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  stock: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RatingConnection {
  pageInfo: PageInfo;
  edges: RatingEdge[];
}

export interface RatingConnectionPromise
  extends Promise<RatingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RatingEdge>>() => T;
  aggregate: <T = AggregateRatingPromise>() => T;
}

export interface RatingConnectionSubscription
  extends Promise<AsyncIterator<RatingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RatingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRatingSubscription>() => T;
}

export interface RatingEdge {
  node: Rating;
  cursor: String;
}

export interface RatingEdgePromise extends Promise<RatingEdge>, Fragmentable {
  node: <T = RatingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RatingEdgeSubscription
  extends Promise<AsyncIterator<RatingEdge>>,
    Fragmentable {
  node: <T = RatingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRating {
  count: Int;
}

export interface AggregateRatingPromise
  extends Promise<AggregateRating>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRatingSubscription
  extends Promise<AsyncIterator<AggregateRating>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TeamConnection {
  pageInfo: PageInfo;
  edges: TeamEdge[];
}

export interface TeamConnectionPromise
  extends Promise<TeamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TeamEdge>>() => T;
  aggregate: <T = AggregateTeamPromise>() => T;
}

export interface TeamConnectionSubscription
  extends Promise<AsyncIterator<TeamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TeamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTeamSubscription>() => T;
}

export interface TeamEdge {
  node: Team;
  cursor: String;
}

export interface TeamEdgePromise extends Promise<TeamEdge>, Fragmentable {
  node: <T = TeamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TeamEdgeSubscription
  extends Promise<AsyncIterator<TeamEdge>>,
    Fragmentable {
  node: <T = TeamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTeam {
  count: Int;
}

export interface AggregateTeamPromise
  extends Promise<AggregateTeam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTeamSubscription
  extends Promise<AsyncIterator<AggregateTeam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TeamSetting {
  id: ID_Output;
  cankick: Boolean;
}

export interface TeamSettingPromise extends Promise<TeamSetting>, Fragmentable {
  id: () => Promise<ID_Output>;
  cankick: () => Promise<Boolean>;
}

export interface TeamSettingSubscription
  extends Promise<AsyncIterator<TeamSetting>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  cankick: () => Promise<AsyncIterator<Boolean>>;
}

export interface TeamSettingConnection {
  pageInfo: PageInfo;
  edges: TeamSettingEdge[];
}

export interface TeamSettingConnectionPromise
  extends Promise<TeamSettingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TeamSettingEdge>>() => T;
  aggregate: <T = AggregateTeamSettingPromise>() => T;
}

export interface TeamSettingConnectionSubscription
  extends Promise<AsyncIterator<TeamSettingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TeamSettingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTeamSettingSubscription>() => T;
}

export interface TeamSettingEdge {
  node: TeamSetting;
  cursor: String;
}

export interface TeamSettingEdgePromise
  extends Promise<TeamSettingEdge>,
    Fragmentable {
  node: <T = TeamSettingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TeamSettingEdgeSubscription
  extends Promise<AsyncIterator<TeamSettingEdge>>,
    Fragmentable {
  node: <T = TeamSettingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTeamSetting {
  count: Int;
}

export interface AggregateTeamSettingPromise
  extends Promise<AggregateTeamSetting>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTeamSettingSubscription
  extends Promise<AsyncIterator<AggregateTeamSetting>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Todo {
  id: ID_Output;
  body: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TodoPromise extends Promise<Todo>, Fragmentable {
  id: () => Promise<ID_Output>;
  body: () => Promise<String>;
  author: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TodoSubscription
  extends Promise<AsyncIterator<Todo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  body: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TodoConnection {
  pageInfo: PageInfo;
  edges: TodoEdge[];
}

export interface TodoConnectionPromise
  extends Promise<TodoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TodoEdge>>() => T;
  aggregate: <T = AggregateTodoPromise>() => T;
}

export interface TodoConnectionSubscription
  extends Promise<AsyncIterator<TodoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TodoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTodoSubscription>() => T;
}

export interface TodoEdge {
  node: Todo;
  cursor: String;
}

export interface TodoEdgePromise extends Promise<TodoEdge>, Fragmentable {
  node: <T = TodoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TodoEdgeSubscription
  extends Promise<AsyncIterator<TodoEdge>>,
    Fragmentable {
  node: <T = TodoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTodo {
  count: Int;
}

export interface AggregateTodoPromise
  extends Promise<AggregateTodo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTodoSubscription
  extends Promise<AsyncIterator<AggregateTodo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TodoProject {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TodoProjectPromise extends Promise<TodoProject>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  todos: <T = FragmentableArray<Todo>>(
    args?: {
      where?: TodoWhereInput;
      orderBy?: TodoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  author: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TodoProjectSubscription
  extends Promise<AsyncIterator<TodoProject>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  todos: <T = Promise<AsyncIterator<TodoSubscription>>>(
    args?: {
      where?: TodoWhereInput;
      orderBy?: TodoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  author: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TodoProjectConnection {
  pageInfo: PageInfo;
  edges: TodoProjectEdge[];
}

export interface TodoProjectConnectionPromise
  extends Promise<TodoProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TodoProjectEdge>>() => T;
  aggregate: <T = AggregateTodoProjectPromise>() => T;
}

export interface TodoProjectConnectionSubscription
  extends Promise<AsyncIterator<TodoProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TodoProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTodoProjectSubscription>() => T;
}

export interface TodoProjectEdge {
  node: TodoProject;
  cursor: String;
}

export interface TodoProjectEdgePromise
  extends Promise<TodoProjectEdge>,
    Fragmentable {
  node: <T = TodoProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TodoProjectEdgeSubscription
  extends Promise<AsyncIterator<TodoProjectEdge>>,
    Fragmentable {
  node: <T = TodoProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTodoProject {
  count: Int;
}

export interface AggregateTodoProjectPromise
  extends Promise<AggregateTodoProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTodoProjectSubscription
  extends Promise<AsyncIterator<AggregateTodoProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ChannelSubscriptionPayload {
  mutation: MutationType;
  node: Channel;
  updatedFields: String[];
  previousValues: ChannelPreviousValues;
}

export interface ChannelSubscriptionPayloadPromise
  extends Promise<ChannelSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChannelPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChannelPreviousValuesPromise>() => T;
}

export interface ChannelSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChannelSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChannelSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChannelPreviousValuesSubscription>() => T;
}

export interface ChannelPreviousValues {
  id: ID_Output;
  name: String;
  slug: String;
  public?: Boolean;
  teamId: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ChannelPreviousValuesPromise
  extends Promise<ChannelPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  public: () => Promise<Boolean>;
  teamId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ChannelPreviousValuesSubscription
  extends Promise<AsyncIterator<ChannelPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  public: () => Promise<AsyncIterator<Boolean>>;
  teamId: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  body: String;
  parentId: ID_Output;
  pageId: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  body: () => Promise<String>;
  parentId: () => Promise<ID_Output>;
  pageId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  body: () => Promise<AsyncIterator<String>>;
  parentId: () => Promise<AsyncIterator<ID_Output>>;
  pageId: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentOptionsSubscriptionPayload {
  mutation: MutationType;
  node: CommentOptions;
  updatedFields: String[];
  previousValues: CommentOptionsPreviousValues;
}

export interface CommentOptionsSubscriptionPayloadPromise
  extends Promise<CommentOptionsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentOptionsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentOptionsPreviousValuesPromise>() => T;
}

export interface CommentOptionsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentOptionsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentOptionsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentOptionsPreviousValuesSubscription>() => T;
}

export interface CommentOptionsPreviousValues {
  comments_open: Boolean;
}

export interface CommentOptionsPreviousValuesPromise
  extends Promise<CommentOptionsPreviousValues>,
    Fragmentable {
  comments_open: () => Promise<Boolean>;
}

export interface CommentOptionsPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentOptionsPreviousValues>>,
    Fragmentable {
  comments_open: () => Promise<AsyncIterator<Boolean>>;
}

export interface CommentSectionSubscriptionPayload {
  mutation: MutationType;
  node: CommentSection;
  updatedFields: String[];
  previousValues: CommentSectionPreviousValues;
}

export interface CommentSectionSubscriptionPayloadPromise
  extends Promise<CommentSectionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentSectionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentSectionPreviousValuesPromise>() => T;
}

export interface CommentSectionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSectionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSectionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentSectionPreviousValuesSubscription>() => T;
}

export interface CommentSectionPreviousValues {
  id: ID_Output;
  pageId: ID_Output;
  url: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentSectionPreviousValuesPromise
  extends Promise<CommentSectionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pageId: () => Promise<ID_Output>;
  url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentSectionPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentSectionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  pageId: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface CustomerPreviousValues {
  id: ID_Output;
  stripeId: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  stripeId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  stripeId: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface FilePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  filename: String;
  mimetype: String;
  encoding: String;
  key: String;
  ETag: String;
  url: String;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  filename: () => Promise<String>;
  mimetype: () => Promise<String>;
  encoding: () => Promise<String>;
  key: () => Promise<String>;
  ETag: () => Promise<String>;
  url: () => Promise<String>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  filename: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  encoding: () => Promise<AsyncIterator<String>>;
  key: () => Promise<AsyncIterator<String>>;
  ETag: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface MessageSubscriptionPayload {
  mutation: MutationType;
  node: Message;
  updatedFields: String[];
  previousValues: MessagePreviousValues;
}

export interface MessageSubscriptionPayloadPromise
  extends Promise<MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessagePreviousValuesPromise>() => T;
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface MessagePreviousValues {
  id: ID_Output;
  body: String;
  parentId: ID_Output;
  url: String;
  filetype: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MessagePreviousValuesPromise
  extends Promise<MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  body: () => Promise<String>;
  parentId: () => Promise<ID_Output>;
  url: () => Promise<String>;
  filetype: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  body: () => Promise<AsyncIterator<String>>;
  parentId: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  filetype: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ModeratorSubscriptionPayload {
  mutation: MutationType;
  node: Moderator;
  updatedFields: String[];
  previousValues: ModeratorPreviousValues;
}

export interface ModeratorSubscriptionPayloadPromise
  extends Promise<ModeratorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ModeratorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ModeratorPreviousValuesPromise>() => T;
}

export interface ModeratorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ModeratorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ModeratorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ModeratorPreviousValuesSubscription>() => T;
}

export interface ModeratorPreviousValues {
  id: ID_Output;
  can_delete: Boolean;
  can_ban: Boolean;
  can_edit: Boolean;
  can_close: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ModeratorPreviousValuesPromise
  extends Promise<ModeratorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  can_delete: () => Promise<Boolean>;
  can_ban: () => Promise<Boolean>;
  can_edit: () => Promise<Boolean>;
  can_close: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ModeratorPreviousValuesSubscription
  extends Promise<AsyncIterator<ModeratorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  can_delete: () => Promise<AsyncIterator<Boolean>>;
  can_ban: () => Promise<AsyncIterator<Boolean>>;
  can_edit: () => Promise<AsyncIterator<Boolean>>;
  can_close: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NotificationSubscriptionPayload {
  mutation: MutationType;
  node: Notification;
  updatedFields: String[];
  previousValues: NotificationPreviousValues;
}

export interface NotificationSubscriptionPayloadPromise
  extends Promise<NotificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotificationPreviousValuesPromise>() => T;
}

export interface NotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NotificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotificationPreviousValuesSubscription>() => T;
}

export interface NotificationPreviousValues {
  id: ID_Output;
  message?: String;
}

export interface NotificationPreviousValuesPromise
  extends Promise<NotificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
}

export interface NotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<NotificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface OrderPreviousValues {
  id: ID_Output;
  total_price: Float;
  confirmed: Boolean;
  currency: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total_price: () => Promise<Float>;
  confirmed: () => Promise<Boolean>;
  currency: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  total_price: () => Promise<AsyncIterator<Float>>;
  confirmed: () => Promise<AsyncIterator<Boolean>>;
  currency: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
  stock: Int;
  price: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  stock: () => Promise<Int>;
  price: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  stock: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RatingSubscriptionPayload {
  mutation: MutationType;
  node: Rating;
  updatedFields: String[];
  previousValues: RatingPreviousValues;
}

export interface RatingSubscriptionPayloadPromise
  extends Promise<RatingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RatingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RatingPreviousValuesPromise>() => T;
}

export interface RatingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RatingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RatingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RatingPreviousValuesSubscription>() => T;
}

export interface RatingPreviousValues {
  id: ID_Output;
  vote: Int;
}

export interface RatingPreviousValuesPromise
  extends Promise<RatingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  vote: () => Promise<Int>;
}

export interface RatingPreviousValuesSubscription
  extends Promise<AsyncIterator<RatingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  vote: () => Promise<AsyncIterator<Int>>;
}

export interface TeamSubscriptionPayload {
  mutation: MutationType;
  node: Team;
  updatedFields: String[];
  previousValues: TeamPreviousValues;
}

export interface TeamSubscriptionPayloadPromise
  extends Promise<TeamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TeamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TeamPreviousValuesPromise>() => T;
}

export interface TeamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TeamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TeamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TeamPreviousValuesSubscription>() => T;
}

export interface TeamPreviousValues {
  id: ID_Output;
  name: String;
  slug: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  confirmed: Boolean;
  online: Boolean;
}

export interface TeamPreviousValuesPromise
  extends Promise<TeamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  confirmed: () => Promise<Boolean>;
  online: () => Promise<Boolean>;
}

export interface TeamPreviousValuesSubscription
  extends Promise<AsyncIterator<TeamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  confirmed: () => Promise<AsyncIterator<Boolean>>;
  online: () => Promise<AsyncIterator<Boolean>>;
}

export interface TeamSettingSubscriptionPayload {
  mutation: MutationType;
  node: TeamSetting;
  updatedFields: String[];
  previousValues: TeamSettingPreviousValues;
}

export interface TeamSettingSubscriptionPayloadPromise
  extends Promise<TeamSettingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TeamSettingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TeamSettingPreviousValuesPromise>() => T;
}

export interface TeamSettingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TeamSettingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TeamSettingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TeamSettingPreviousValuesSubscription>() => T;
}

export interface TeamSettingPreviousValues {
  id: ID_Output;
  cankick: Boolean;
}

export interface TeamSettingPreviousValuesPromise
  extends Promise<TeamSettingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  cankick: () => Promise<Boolean>;
}

export interface TeamSettingPreviousValuesSubscription
  extends Promise<AsyncIterator<TeamSettingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  cankick: () => Promise<AsyncIterator<Boolean>>;
}

export interface TodoSubscriptionPayload {
  mutation: MutationType;
  node: Todo;
  updatedFields: String[];
  previousValues: TodoPreviousValues;
}

export interface TodoSubscriptionPayloadPromise
  extends Promise<TodoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TodoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TodoPreviousValuesPromise>() => T;
}

export interface TodoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TodoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TodoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TodoPreviousValuesSubscription>() => T;
}

export interface TodoPreviousValues {
  id: ID_Output;
  body: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TodoPreviousValuesPromise
  extends Promise<TodoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  body: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TodoPreviousValuesSubscription
  extends Promise<AsyncIterator<TodoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  body: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TodoProjectSubscriptionPayload {
  mutation: MutationType;
  node: TodoProject;
  updatedFields: String[];
  previousValues: TodoProjectPreviousValues;
}

export interface TodoProjectSubscriptionPayloadPromise
  extends Promise<TodoProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TodoProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TodoProjectPreviousValuesPromise>() => T;
}

export interface TodoProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TodoProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TodoProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TodoProjectPreviousValuesSubscription>() => T;
}

export interface TodoProjectPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TodoProjectPreviousValuesPromise
  extends Promise<TodoProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TodoProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<TodoProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email?: String;
  set_private: Boolean;
  username: String;
  password: String;
  gitHubId?: ID_Output;
  facebookId?: ID_Output;
  twitterId?: ID_Output;
  gmailId?: String;
  private: Boolean;
  confirmed: Boolean;
  online: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  role: UserRole;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  set_private: () => Promise<Boolean>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  gitHubId: () => Promise<ID_Output>;
  facebookId: () => Promise<ID_Output>;
  twitterId: () => Promise<ID_Output>;
  gmailId: () => Promise<String>;
  private: () => Promise<Boolean>;
  confirmed: () => Promise<Boolean>;
  online: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  role: () => Promise<UserRole>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  set_private: () => Promise<AsyncIterator<Boolean>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  gitHubId: () => Promise<AsyncIterator<ID_Output>>;
  facebookId: () => Promise<AsyncIterator<ID_Output>>;
  twitterId: () => Promise<AsyncIterator<ID_Output>>;
  gmailId: () => Promise<AsyncIterator<String>>;
  private: () => Promise<AsyncIterator<Boolean>>;
  confirmed: () => Promise<AsyncIterator<Boolean>>;
  online: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  role: () => Promise<AsyncIterator<UserRole>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "File",
    embedded: false
  },
  {
    name: "Rating",
    embedded: false
  },
  {
    name: "Notification",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Moderator",
    embedded: false
  },
  {
    name: "CommentOptions",
    embedded: false
  },
  {
    name: "CommentSection",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Message",
    embedded: false
  },
  {
    name: "Channel",
    embedded: false
  },
  {
    name: "Team",
    embedded: false
  },
  {
    name: "TeamSetting",
    embedded: false
  },
  {
    name: "Todo",
    embedded: false
  },
  {
    name: "TodoProject",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "OnlineStatus",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466/prismadb/dev`
});
export const prisma = new Prisma();
